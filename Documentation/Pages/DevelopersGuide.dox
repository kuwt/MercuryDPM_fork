/*! \page DevelopersGuide Guidelines for Users and Developers

This guide is intended to make you familiar with the coding structure of MercuryDPM. 
We discuss two levels of code development:
 - \subpage DevelopersGuideDriver, 
 - \subpage DevelopersGuideKernel,

For more information, see the \subpage FAQDevelopers,


Also take a look at the section \subpage Test.

###Definitions

The *kernel* contains general code that is developed to be used in many applications, e.g. the definition of a species, particle, wall, boundary, or the class Mercury3D, which is used to define the interactions between the different objects in a DPM code. 
This code is mostly developed in classes. 
The corresponding source files are stored in the Kernel/ directory.

A *driver* uses the classes defined in the kernel to create a concrete simulation, e.g.a rotating drum, a vibrated bed, or the flow over a bed. It typically consists of a single cpp file in the Drivers/ directory. 

We refer to a person writing specific application/driver code in MercuryDPM as *user*, and to a person developing kernel features as a *developer*. Everyone can become a user by downloading the code from http://www.mercurydpm.org/; once you have some experience in using the code, you are welcome to join the developer team; just contact us here: http://mercurydpm.org/development/how-to-join-the-developers. 
*/

/*! 
\page DevelopersGuideDriver  Developing an application/driver code
A driver file usually contains a class derived from Mercury3D in which the concrete parameters of the application are defined, such as species, particles, walls, boundaries, time step, ..., and a main function where the class is declared and the time integration routine (solve) is called. Thus, the basic setup looks like this:

    \code{.cpp}    
    #include <Mercury3D.h>

    class Example : public Mercury3D 	
    { 
    public:
      void setupInitialConditions() override
      {	
        // define your particles, walls, boundaries here
      }
    };

    int main(int argc, char *argv[])
    {
      Example problem;
      // define global variables, species here
      problem.solve(argc, argv);
      return 0;
    }
    \endcode

This file defines a class named \c Example, that is derived from \c Mercury3D. It overrides the function setupInitialConditions (which is empty by default) with a function where the simulation objects (particles, walls, boundaries, species) are defined. 

Then the main function is defined (which is the function that is executed when you run the executable): First, the *Example* class is instantiated (a concrete instance of the class is created and stored in memory). Then, the global variables are set, such as name, gravity, spatial/temporal domain. Finally, the time integration routine (solve) is called.

### Global variables

The following global variables should be set:
  \code{.cpp}
  problem.setName("Example");
  problem.setXMin(0.0);
  problem.setYMin(0.0);
  problem.setZMin(0.0);
  problem.setXMax(1.0);
  problem.setYMax(1.0);
  problem.setZMax(1.0);
  problem.setTimeMax(2.0);
  problem.setTimeStep(1e-4);
  \endcode
The first command sets the name variable to Example, so the output files will be named \c Example.data, \c Example.restart, ...
The next six commands set the dimensions of the system that are used in displaying the output.
Finally, the final time and the time step are set.

There are additional global parameters that can be set here, such as
 - gravity, e.g. in z-direction
  \code{.cpp}
  problem.setGravity(Vec3D(0.0, 0.0, -9.8)); //sets gravity
  \endcode
 - the amount of time steps between each write command
  \code{.cpp}
  problem.setSaveCount(50); //writes every 50th time step
  \endcode
 - additional output parameters for the xBalls viewer
  \code{.cpp}
  problem.setXBallsAdditionalArguments("-v0"); //displays velocity vectors in xBalls
  \endcode
 - ...

### Species

A species can be defined as follows:

  \code{.cpp}
  //include above all other code:
  #include <Species/LinearViscoelasticSpecies.h>
  
  //include in main, before solve:
  LinearViscoelasticSpecies species; // defines linear-viscoelastic contact law
  species.setDensity(2500.0);        // sets the particle density
  species.setStiffness(200.0);       // sets the linear contact stiffness
  species.setDissipation(0.0);       // sets the dissipation
  problem.speciesHandler.copyAndAddObject(species);
  \endcode

Other contact laws are possible; see the documentation of Species for more details.

### Particles

A particle can be defined as follows:

  \code{.cpp}
  //include above all other code:
  #include <Particles/BaseParticle.h>
  
  //include in setupInitialConditions:
  BaseParticle p;                       // defines a new particle
  p.setSpecies(speciesHandler.getObject(0)); // sets particle species
  p.setRadius(0.5);                     // sets particle radius
  p.setPosition(Vec3D(0.0,0.0,0.0));    // sets particle position
  p.setVelocity(Vec3D(1.0,0.0,0.0));    // sets particle velocity
  particleHandler.copyAndAddObject(p);  // copies particle into the handler 
  \endcode

See the documentation of BaseParticle for more details.

### Walls

A planar bottom wall at the bottom of the domain can be defined as follows:

  \code{.cpp}
  //include above all other code:
  #include <Walls/InfiniteWall.h>
  
  //include in setupInitialConditions:
  InfiniteWall w;                            // defines a new planar wall
  w.setSpecies(speciesHandler.getObject(0)); // sets wall species
  w.set(Vec3D(0,0,-1),Vec3D(0,0,getZMin())); // defines normal into the wall and point on the wall
  wallHandler.copyAndAddObject(w);           // copies wall into the handler 
  \endcode

Other walls are possible; see the documentation of WallHandler for more details.

### Boundaries

A periodic boundary in x-direction can be defined as follows:

  \code{.cpp}
  //include above all other code:
  #include "Boundaries/PeriodicBoundary.h"
  
  //include in setupInitialConditions:
  PeriodicBoundary b0;                     // defines a new periodic boundary
  b.set(Vec3D(1,0,0),getXMin(),getXMax()); // defines normal and position of the boundary 
  boundaryHandler.copyAndAddObject(b);     // copies boundary into the handler 
  \endcode

Other boundaries are possible; see the documentation of BoundaryHandler for more details.

### Overriding functions
In some cases it is not enough to define suitable initial conditions. This is done by overriding certain functions in the Mercury3D class, just as we are overriding setupInitialConditions.

For example, to define a criterium to stop the simulation, one can override the 
    \code{.cpp}
    //include as member function in class definition:
    bool continueSolve() const override
    {
        if (getKineticEnergy()<1e-5*getElasticEnergy())
            return false;
        else
            return true;
    }
    \endcode
In this case, the simulation is stopped as soon as the kinetic energy drops below 0.00001 times the elastic energy stored in the contact springs (a useful criteria to determine arresting flow).

For more examples, see \subpage DevelopersGuideOverride.

### Avoiding magic numbers
While the above example works, we advise you to avoid the number of explicitly used parameters such as the tolerance \f$1e-5\f$ inside the class definition. A good coding guideline is to define all  parameters in one place (the main function), with the exception of the particles, walls and boundaries, so they can easily be found and changed later.

    \code{.cpp}
    //include as member function in class definition:
    bool continueSolve() const override
    {
        if (getKineticEnergy()<tolerance*getElasticEnergy())
            return false;
        else
            return true;
    }

    //include as member variable in class definition:
    Mdouble tolerance = 0.0;

    //include in main function:
    problem.tolerance = 1e-5;
    \endcode

### Creating new drivers
You can start a new driver code by creating your own user directory. 
First, chose a \c UserName, then add a folder to the user directory and create a new source file, e.g. \c Example.cpp, which for convenience is copied here from the file \c Tutorial1.cpp.
cd ~/MercurySource/Drivers/USER
svn mkdir UserName
cd UserName
svn cp ../../Tutorials/Tutorial1.cpp Example.cpp

Now write your code in the Example.cpp file. Note, you cannot yet execute your code, as the Makefiles in your build directory doesn't know about the new file. To update your Makefiles, use cmake. Note, the file name of your source file has to be unique, otherwise you get error messages.
cd ~/MercuryBuild
cmake .

Now you can build and execute your new code:
cd ~/MercuryBuild/Drivers/USER/UserName
make Example

Note, as we currently only support MercuryDPM on Linux/Mac OS, these instructions are only valid for such systems.

*/

/*! 
\page DevelopersGuideKernel Developing a kernel feature

## Coding Guidelines

Developers should adhere to the following guidelines when developing new functionalities in the Kernel:

- Always document your changes.
  If you modified a function/variable/class, check if the documentation is still correct. If you developed a new function/variable/class, add a brief comment above the  declaration in the header file and a detailed comment (including an explanation of the in- and output variables) above the definition in the source file.
- We use C++11 commands. 
  Our general guideline is to only use commands that have been implemented in the common C++ compilers for at least 24 months, which includes most of the C++11 standard.
- Each feature should be tested; see Testing section below for details.
- Please adhere to the coding style, see http://MercuryDPM.org/development/coding-style-of-the-kernel.


## Insight into the code

The \ref IntroductionToTheCode is a useful document to gain insight into the existing code.

## Testing

See \subpage TESTING.

# Committing your code to SVN
See \subpage SVNCOMMIT.

# Logging
See \subpage LoggerGuide.

# Implementing a new contact law

See \subpage HowToCreateANewSpecies.


\page TESTING Testing your code

To ensure that future updates to the code don't break existing features, MercuryDPM has a suite of test codes that each new commit to has to pass.

Each kernel feature should be tested to ensure future updates to the code don't break existing features. Users are also encouraged to write tests for their own codes, to detect quickly if an update to the Kernel caused a change in the USER code.

You can run the test suite by calling *make fullTest* in your build directory. The test suite first checks that all codes in the Drivers directory compile, then tests the test codes.

There are 3 types of tests, which are recognizable by the ending of the *.cpp* file name:
-# <b>UnitTest</b>:
  All codes whose file name ends with *UnitTest.cpp* are recognised by the test suite as self tests.
  Most of these tests reside in Drivers/UnitTests.
  Those tests should run in 1 second or less and have internal checks if the output is valid (for example, they might check if the position or velocity of a particle at a given time is correct; see for example UnitTests/AdhesiveForceUnitTest.cpp).
  To keep those tests efficient, the check should not require comparison with data files).
-# <b>SelfTest</b>:
  All codes whose file name ends with *SelfTest.cpp* are recognised by the test suite as unit tests.
  Those tests should run in 10 seconds or less and create output files that are checked against *gold data*.

  <b>To create your own self test</b>: Let's assume you developed a new Driver, for example *Compression.cpp* in *MercurySource/Drivers/USER/JohnDoe*, and you want to create a test to ensure that any new Kernel features won't affect the results of your code. To do so,
  - Create a new code *CompressionSelfTest.cpp* in the same directory that runs in 10 seconds or less and creates an output file (e.g. *CompressionSelfTest.restart*) you would like to test against. Please keep the size of this output file as small as possible.
  - Compile and execute your new self test and copy the *CompressionSelfTest.restart* to the directory MercurySource/Drivers/USER/JohnDoe/SelfTestData (create the directory if it doesn't exist yet).
  - Now use *cmake .* in the MercuryBuild directory to update the Makefiles and *make fullTest*  to check that all tests (including the newly created one compiles)
  - Use *svn add* to add the new files to the repository and commit (see \ref SVNCOMMIT).
-# <b>Demo</b>:
  All codes whose file name ends with *Demo.cpp* are recognised by the test suite as demos.
  Most of these tests reside in Drivers/MercurySimpleDemos.
  These are codes that run in 5 minutes or less, that illustrate a code feature. No special checks are done for Demo codes.

Before any new feature is committed, all tests have to be run and return a positive result (see \ref SVNCOMMIT). Any commit that breaks one or more tests is a violation of the MercuryDPM coding standard, and is punishable by a round of beers to all other developers. To execute all test, run the following command before committing:
\code{.cpp}
cd MercuryBuild
make fullTest
\endcode

Note that tests can also be run individually, e.g. to run *FreeFallUnitTest* use
<i>ctest -R FreeFallUnitTest</i>

\page SVNCOMMIT Committing your code to SVN

If you want to commit new code to MercuryDPM, follow these steps. 

-# <b>Update</b> your svn repository to the latest version of Mercury. This ensures that you have no conflicts with the changes other people have made since you last checked out.
\code{.sh}
$ cd MercurySource
$ svn up
Updating '.':
U    Drivers/MercurySimpleDemos/CMakeLists.txt
A    Documentation/Pages/DoxygenDocumentationForDummies.dox
Updated to revision 1556.
\endcode
If you do get conflicted files, read the <a href="https://ariejan.net/2007/07/04/how-to-resolve-subversion-conflicts/">svn manual</a> to find out how to resolve these conflicts.



-# <b>Check</b> your changes; you can use *svn status* to see which files have changed,
\code{.sh}
$ svn status
M       Documentation/Pages/DevelopersGuide.dox
\endcode
Use *svn diff* to see which changes you have made to each file and review them. A full list of svn commands can be found using *svn help*.
\code{.sh}
$ svn diff Documentation/Pages/DevelopersGuide.dox 
Index: Documentation/Pages/DevelopersGuide.dox
===================================================================
@@ -236,36 +236,62 @@
-## Submitting your code to SVN
+# Committing your code to SVN
\endcode

-# <b>Test</b> have to be run before any new feature is committed, and return a positive result. Any commit that breaks one or more tests is a violation of the MercuryDPM coding standard, and is punishable by a round of beers to all other developers. To execute all test, run the following command before committing:
\code{.sh}
$ cd MercuryBuild
$ make fullTest
\endcode

-# <b>Write a message</b> detailing your changes, and submit:
\code{.sh}
$ more file
Feature finished: Mercury Logger
-I have adapted the logger such that it works now fully as it should
-Asserts will be handled by the logger using logger.assert(..) and logger.assert_always(..)
-Only ExtendedMath MatrixSymmetric and NumericalVector contained asserts, they have been rewritten to the logger.assert
$ svn commit -F file
\endcode
Alternatively, use a simple message string,
\code{.sh}
$ svn commit -m 'MDPM-116 #resolve #comment Updating instructions on how to submit to MercuryDPM to the Code Developer Guidelines'
\endcode

-# <b>Jira markups</b>: If the change concerns a specific <a href="http://jira.mercurydpm.org">jira job</a>, mention the job number in the message; you can also pass commands like \#resolve to jira, so the job is automatically closed. Examples:
\code{.sh}
$ svn commit -m 'MDPM-116 #resolve #comment Updating instructions on how to submit to MercuryDPM to the Code Developer Guidelines'
$ svn commit -m 'Updating instructions on how to submit to MercuryDPM to the Code Developer Guidelines #MDPM-43'
\endcode

*/

/*! 
\page DevelopersGuideOverride Overriding functions
Another example is to add additional output to the Example.ene file, in this case the number of particles.
    \code{.cpp}
    //include as member functions in class definition:
    void writeEneHeader(std::ostream& os) const override
    {
        os << setw(8) << "N";
        DPMBase::writeEneHeader(os);
    }

    void writeEneTimeStep(std::ostream& os) const override
    {
        os << setw(8) << particleHandler.getNumberOfObjects();
        DPMBase::writeEneTimeStep(os);
        
    }
    \endcode

To change the terminal output after each written time step, use:
    \code{.cpp}
    //include as member functions in class definition:
    void printTime() const override
    {
        std::cout << "N"  << particleHandler.getNumberOfObjects() << std::endl;
    }
    \endcode

Other functions can be overridden, most notably:
  \code{.cpp}
    // to add additional body forces, such as background dissipation:
    void computeExternalForces(BaseParticle* PI) override {...} 
    // to add commands before restart, such as deleting old files:
    void actionsOnRestart() override {...} 
    // to add commands before the first time step, but after initial forces are computed:
    void actionsBeforeTimeLoop() override {...} 
    // to add commands before each time step:
    void actionsBeforeTimeStep() override {...} 
    // to add commands after each time step:
    void actionsAfterTimeStep() override {...} 
    // to add commands after  time integration:
    void actionsAfterSolve() override {...} 
  \endcode

\page FAQDevelopers FAQ for developers

 -# How do I create a directory for my codes?
See \subpage UserDir

\page UserDir How do I create a directory for my codes?
When you start developing MercuryDPM applications ("Drivers"), you need a directory in which to store them.
All MercuryDPM developers can should create a directory to store their aplications, and use svn for version control. Here is how you do it:
 -# Open a terminal, enter the subfolder Drivers/USER in the source directory, and svn-copy the template USER directory into a directory named after you, e.g.
\code{.cpp}
MercurySource/Drivers/USER$ svn cp Template Marlin
\endcode
 -# Enter your directory. If you have already written a driver code, svn-remove the template driver, copy your driver into your folder and svn-add the driver.
\code{.cpp}
MercurySource/Drivers/USER$ cd Marlin
MercurySource/Drivers/USER/Marlin$ cp $DIRECTORY/MyFirstDriver.cpp .
MercurySource/Drivers/USER/Marlin$ svn add MyFirstDriver.cpp
MercurySource/Drivers/USER/Marlin$ svn rm TemplateDriver.cpp
\endcode
 If you are just starting to develop a driver, and svn-rename the template driver to the name you want to give your driver, e.g.
\code{.cpp}
MercurySource/Drivers/USER$ cd Marlin
MercurySource/Drivers/USER/Marlin$ svn mv TemplateDriver.cpp MyFirstDriver.cpp
\endcode
 -# return to your build directory and update cmake.
\code{.cpp}
MercurySource/Drivers/USER/Marlin$ cd ../../../../MercuryBuild
MercuryBuild$ cmake .
-- Build files have been written to: /Users/weinhartt/Mercury/Trunk/cmake-build-debug
\endcode
Updating cmake made a make command for your driver, you can test this:
\code{.cpp}
MercuryBuild$ make MyFirstDriver
[100%] Built target MyFirstDriver
\endcode

 -# then check-in your changes (after testing that all codes compile):
\code{.cpp}
MercuryBuild$ make fullTest
MercuryBuild$ cd ../MercurySource
MercurySource$ svn st
A  +    Drivers/USER/Marlin
A  +    Drivers/USER/Marlin/MyFirstDriver.cpp
D  +    Drivers/USER/Marlin/TemplateDriver.cpp
MercurySource$ svn ci -m "added a USER directory named Marlin"
\endcode
Now you can modify the driver code to your specific application.
*/


