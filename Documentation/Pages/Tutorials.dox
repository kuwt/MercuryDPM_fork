
/*! \page Tutorials Fun with MercuryDPM (Tutorials)

The idea behind these tutorials, listed below, is to help the user improve his/her rapport with coding and problem solving in MercuryDPM. Most of the tutorials are designed to solve a simple problem. Each tutorial illustrates a new feature of MercuryDPM and gradually builds up on its level of difficulty.\n
\n
- \subpage BeginnerTutorials
- \subpage AdvancedTutorials

You can find a list of all tutorials \subpage Tcodes "here".

In case of any typos or suggestions for new tutorials, please do not hesitate to contact the MercuryDPM team.
*/

/*! \page BeginnerTutorials Beginner tutorials
This page contains the following tutorials: \n

- \ref T1
- \ref T2
- \ref T3
- \ref T4
- \ref T5
- \ref T6
- \ref T7
- \ref T8
- \ref T9
- \ref T11
- \ref T12


\section T1 T1: Particle motion in outer space
\image html Tutorials/T1/Tutorial1.jpg Particle moving with a constant velocity in outer space.

#### Problem description:
The first tutorial is setup to simulate a particle moving with a constant velocity in the absence of gravity. You can find the simulation setup in \b Tutorial1.cpp
The detailed description of this tutorial is presented below.\n

###Headers:
The headers are necessary to set up the simulations. They come from the kernel and standard libraries (see \ref DevelopersGuideKernel). Headers files usually have a <EM> .h </EM> or <EM> .hpp </EM> extensions. For example:
\snippet Drivers/Tutorials/Tutorial1.cpp T1:headers

###Before main function:

A class is the guide for objects to connect with handlers. \n

You can find in the code:

\code class Tutorial1 : public Mercury3D \endcode

Here is defined the class Tutorial1, which is inherited from the main class  \ref Mercury3D. Then, you can call the function to fit the initial conditions of the problem:

\code void setupInitialConditions()\endcode

It creates the problems’ initial conditions to define the radius, position, velocity of particles. In order to create a particle, the following structure must be used:

\snippet Drivers/Tutorials/Tutorial1.cpp T1:createParticle

The particle data members as positions, radius and velocities are pointed by using an object (P0) to their class member. For the case of the mentioned data members, the class member is called \ref BaseParticle. Then, the defined information is sent to its corresponding handler: \b  particleHandler by using the function \ref copyAndAddObject

###Main function:
In the main function, the global parameters of the problem are defined. It includes gravity, spatial dimensions (x,y,z), total run time, the type of contact law, etc. \n
The object 'problem' is an instance of the defined class \ref Tutorial1. Global parameters and species will point to the object 'problem'.

\code
Tutorial1 problem;
\endcode

Then, the data members are defined as:

\snippet Drivers/Tutorials/Tutorial1.cpp T1:problemSetup

Subsequently, the \ref species of the problem are defined. It means, the properties (density,stiffness) and the corresponding contact law (for this tutorial, see \ref LinearViscoelasticSpecies).
Initially, when a particle is created, it attains the properties of a default species type with ‘0’ as its index.

\snippet Drivers/Tutorials/Tutorial1.cpp T1:speciesProp

Here, 'species' is an object of the class: \ref LinearViscoelasticSpecies. Data members are fitted to point to this object, and then, coppied and added to their corresponding handler \ref speciesHandler.

Outputs:\n

Data output is vital to analyse simulations, which leads to defining ways to save the simulation data for post processing.\n
The simulations generate several types of data files.

\snippet Drivers/Tutorials/Tutorial1.cpp T1:output

Thereby, data members and member functions are pointed to the object 'problem'.\n

For XBalls users, additional display options can be set as below

\snippet Drivers/Tutorials/Tutorial1.cpp T1:visualOutput

After all the simulation parameters are set, we reach a point where we put all the above bits of code in action by the following statements

\snippet Drivers/Tutorials/Tutorial1.cpp T1:solve

\n
\section T2 T2: Particle motion on earth
\image html Tutorials/T2/Tutorial2.jpg Particle falling due to gravity.

#### Problem description:
In \b Tutorial2.cpp, we simulate a particle when dropped under the influence of gravity, \f$ g = 9.81 m/s^2\f$. Basically, this tutorial is an extension of \b Tutorial1.cpp with few minor changes.\n
All we need to do is to change the initial particle position and velocity in the inherited class Tutorial2.\n

\snippet Drivers/Tutorials/Tutorial2.cpp T2:createParticle

Also, the gravity vector in the main function:

\snippet Drivers/Tutorials/Tutorial2.cpp T2:problemSetup

\n
\section T3 T3: Bouncing ball (elastic)
\image html Tutorials/T3/Tutorial3.jpg Particle bouncing off the blue wall.

#### Problem description:
The \b Tutorial3.cpp simulates a particle bouncing off a wall. It is assumed the collistion between the particle and the wall is elastic by implying that the restitution coefficient is unity. It means that the particle velocity before and after collision remains the same.
Additionally, we will learn how to add a wall over which the ball bounces.

### Headers:
The header \ref InfiniteWall.h is included.

\snippet Drivers/Tutorials/Tutorial3.cpp T3:headers


### Before the main class:
The class \ref InfiniteWall is included in the inherited class \ref Tutorial3:

\snippet Drivers/Tutorials/Tutorial3.cpp T3:class

Where the object "w0" is an instance of the class \b InfiniteWall. Then, the function "copyAndAddObject" coppy and add the object to its corresponding handler. The above set of statements, create and place the wall at \f$ Z_{min} \f$.\n

Note: Don’t forget to include the InfiniteWall.h header, as shown in the header section. In some sense, creation and addition of a wall is similar to creation and addition of a particle.

\n
\section T4 T4: Bouncing ball with dissipation (inelastic)
\image html Tutorials/T4/Tutorial4.jpg Particle bouncing off the blue wall with restitution coefficient.

#### Problem description:
In \b Tutorial4.cpp, the difference between an elastic and inelastic collision between a particle and a wall is illustrated. The only difference between \ref Tutorial3.cpp and \ref Tutorial4.cpp is the value of the restitution coefficient:
\code double rc = 0.88; // restitution coefficient \endcode
See \ref T4code for more details.

\n
\section T5 T5: Elastic collision (2 particles)
\image html Tutorials/T5/Tutorial5.jpg Particles moving towards each other.

Problem description:\n
So far, in the above tutorials, we have seen how a particle and a wall interact during a collision. In this tutorial, we illustrate how two particles interact using \b Tutorial5.cpp. For this purpose, we need two particles. The particles may or may not be of the same species type. But, here we shall assume they are of same species and same size.\n

### Before the main function
\snippet Drivers/Tutorials/Tutorial5.cpp T5:class
On comparison between the above class and class Tutorial1, we see how an additional particle is added. Two particles are created, and positioned oppositely apart at a certain distance between them. Both the particles, have a certain velocity directing them towards each other.

\n
\section T6 T6: Elastic collisions with periodic boundaries
\image html Tutorials/T6/Tutorial6.jpg (a) Illustrates the idea behind periodic boundaries, particle exiting boundary b2 re-enters through boundary b1 <br> (b) Illustrates the problem setup.

#### Problem description:
In order to have multiple collisions, \ref Tutorial5.cpp is fitted with periodic boundaries in X.

### Headers:
\snippet Drivers/Tutorials/Tutorial6.cpp T6:headers
The header \ref PeriodicBoundary.h is included.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial6.cpp T6:class
In the Class Tutorial6\n
(i) we create two particles of same type and different sizes. (ii) we setup periodic boundaries in X-direction as
\snippet Drivers/Tutorials/Tutorial6.cpp T6:periodicBoundary

Where "b0" is an instance of the class \ref  PeriodicBoundary. Then, the object is copied and added to its corresponding handler:  \ref boundaryHandler.

\n
\section T7 T7: Motion of a particle in a two dimensional (2D) box
\image html Tutorials/T7/Tutorial7.jpg Particle motion in a box (blue and black denote the walls).

#### Problem description:
In previous tutorials, we have seen how a particle interacts with a wall and itself. In this tutorial, we will design boxes of different shapes by using more than one wall. As an example, in absence of gravity, we will simulate a particle moving in a two dimensional square shaped box. We consider two dimensions only for the sake of simplicity.
The same idea was introduced in \ref Tutorial3.cpp.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial7.cpp T7:class
In this class, we setup a 2D square shaped box or a polygon by adding more walls as shown above. In total, we have 4 walls forming our box within which the particle will traverse.
Note: As we simulate in 2D, no walls are set in z-direction.

### Main function:
As our simulation is two dimensional, we set the system dimensions as 2
\code problem.setSystemDimensions(2);\endcode

The complete code for the above problem description can be found in \ref Tutorial7.cpp.

\n
\section T8 T8: Motion of a particle in a box with an obstacle
\image html Tutorials/T8/Tutorial8.jpg

#### Problem description:
We extend the problem setup of Tutorial 7, by adding a rectangular block as shown in the above figure. To create this block of wall or obstacle, we will use the Class \ref IntersectionOfWalls. Before we go ahead it is advised to know the difference between an infinite wall and finite wall, see \ref WallTypes. As an example, we create an obstacle using a set of finite walls and place it within the box created using a set of infinite walls. See the above figure.

### Headers:
\snippet Drivers/Tutorials/Tutorial8.cpp T8:headers

The header \ref IntersectionOfWalls.h is included.

### Before the main function:
\image html Tutorials/T8/Tutorial8b.jpg

To add intersection walls, we use:
\snippet Drivers/Tutorials/Tutorial8.cpp T8:finiteWall

where "w1" is an instance of the class \ref IntersectionOfWalls. This surface (wall) will have the properties of the index 0: "getObject(0)". Then, the object is coppied and added to its corresponding handler:  \ref wallHandler.

\n
\section T9 T9: Motion of a ball over an inclined plane (Sliding + Rolling)
\image html Tutorials/T9/Tutorial9.jpg

#### Problem description:
the motion of three particles over an inclined plane is presented in \ref Tutorial9.cpp. Here, the particles are fitted with different features.

### Headers:

\snippet Drivers/Tutorials/Tutorial9.cpp T9:headers

For \ref Tutorial9.cpp, the header which implements the elastic properties and contact force modelc has been changed. In order to include the rolling and sliding effects, \ref LinearViscoelasticFrictionSpecies.h is used.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial9.cpp T9:class

Three particles are fitted with radius, initial positions and initial velocities.Then, all particles are coppied and added to their corresponding handler. \n
It is defined the object 'w0' as an instance of the class  InfiniteWall. For this tutorial, the surface will have the same properties of "object0". It means the surface and the first particle will have the same elastic properties.

### Main function:

\snippet Drivers/Tutorials/Tutorial9.cpp T9:main

The main function of \ref Tutorial9.cpp presents how the elastic features of particles are defined. Also, a new function is added to combine features of different indexes: getMixedObject.



\n
\section T11 T11: Axisymmetric walls inside a cylindrical domain
\image html Tutorials/T11/Tutorial11.png
#### Problem description:

This tutorial explains how to include axisymmetric walls inside a cylindrical domain. Also, the user will find an useful
implementation of how to create polydisperse particle size distribution and perform internal validation tests. The full code
can be found in \ref Tutorial11.cpp

### Headers:

To work with axisymmetric walls, the user needs to add the following headers:

\snippet Drivers/Tutorials/Tutorial11.cpp T11:headers

### Before the main function:

The class Tutorial 11 contains the constructor Tutorial 11

\snippet Drivers/Tutorials/Tutorial11.cpp T11:constructor

This constructor is an instance of the main class. Here it's defined the global output and non-changeable parameters.

In this tutorial, it's overrided the member function setupInitialConditions(), which doesn't return any value (defined then as void).

\snippet Drivers/Tutorials/Tutorial11.cpp T11:initialConditions

First, it is added the cylinder, then the prism shape or cone that represents the outer part. A flat surface is included in the middle to stop the downforward flow until a specific time. After adding the walls, the species of the particles are included. All particles have the same properties and they are randomly
distributed.

An additional member function is included.

\snippet Drivers/Tutorials/Tutorial11.cpp T11:functiontime

This overide function moves the flat surface to the base domain. It happens at a defined time, thus the particles can continue to flow.

### Main function:
The main function of this tutorial includes the setup parameters and the tests for a valid collision time and restitution coefficient.

\snippet Drivers/Tutorials/Tutorial11.cpp T11:main

\n
\section T12 T12: Creating objects by using Prisms
\image html Tutorials/T12/Tutorial11.png
#### Problem description:

This tutorial explains how to define objects in space with the Prism function. Also, the user will find that you can presecribe the location and motion of the object. The full code
can be found in \ref Tutorial12.cpp

### Headers:

To work with prismatic walls in this tutorial, the user needs to add the following headers:

\snippet Drivers/Tutorials/Tutorial12.cpp T12:headers

### Before the main function:

The walls and Prism object are all predefined in the initial conditions.

\snippet Drivers/Tutorials/Tutorial12.cpp T12:initialConditions

The first part in the the initial conditions is defining the particle.

\snippet Drivers/Tutorials/Tutorial12.cpp T12: Define particle

After defining the particle that outer walls are generated by using four finite walls as seen in previous tutorials

\snippet Drivers/Tutorials/Tutorial12.cpp T12: Define outer walls

To creat the prism we have to do the following: First one creates an instance of IntersectionOfWalls "w1". Next the species are assigned. This line is followed by defining a 3D vector "Points" with space for four vertices.
After that the location of the four vertices are defined. Then, by using w1.createPrism(Points) the prism is formed centered at the origin.

\snippet Drivers/Tutorials/Tutorial12.cpp T12: Create object

Now the object has been formed you can prescribe several properties of the object such as the angular velocity or translational velocity (using setVelocity).
Notice that when using setAngularVelocity the object rotates around the origin, so if an object is located at the origin it will rotate around its own axis while located elsewhere it will rotate around the origin.
It is essential that you set velocities and positions in the correct order such that you get the desired motion.

\snippet Drivers/Tutorials/Tutorial12.cpp T12: Set Angular Velocity
\snippet Drivers/Tutorials/Tutorial12.cpp T12: Set Velocity
\snippet Drivers/Tutorials/Tutorial12.cpp T12: Set Position

### Main:

In the main function the problem is defined in the problem instance, an instance of class Tutorial 12.

\snippet Drivers/Tutorials/Tutorial12.cpp T12: constructor

At the end of the main function we call the solve function

\snippet Drivers/Tutorials/Tutorial12.cpp T12: Solve Problem

After solving the problem you can visualize the results and see the effect of the motion of the object on the trajectory of the particle.

\n 



\page Tcodes Codes for tutorials

\section T1code Particle motion in outer space (code)
Return to tutorial \ref T1
\includelineno Drivers/Tutorials/Tutorial1.cpp
Return to tutorial \ref T1

\section T2code Particle motion on earth (code)
Return to tutorial \ref T2
\includelineno Drivers/Tutorials/Tutorial2.cpp
Return to tutorial \ref T2

\section T3code Bouncing ball - elastic (code)
Return to tutorial \ref T3
\includelineno Drivers/Tutorials/Tutorial3.cpp
Return to tutorial \ref T3

\section T4code Bouncing ball - inelastic (code)
Return to tutorial \ref T4
\includelineno Drivers/Tutorials/Tutorial4.cpp
Return to tutorial \ref T4

\section T5code Elastic collision - 2 particles (code)
Return to tutorial \ref T5
\includelineno Drivers/Tutorials/Tutorial5.cpp
Return to tutorial \ref T5

\section T6code Elastic collisions with periodic boundaries (code)
Return to tutorial \ref T6
\includelineno Drivers/Tutorials/Tutorial6.cpp
Return to tutorial \ref T6

\section T7code Motion of a particle in a two dimensional box (code)
Return to tutorial \ref T7
\includelineno Drivers/Tutorials/Tutorial7.cpp
Return to tutorial \ref T7

\section T8code Motion of a particle in a box with an obstacle (code)
Return to tutorial \ref T8
\includelineno Drivers/Tutorials/Tutorial8.cpp
Return to tutorial \ref T8

\section T9code Motion of a ball over an inclined plane (code)
Return to tutorial \ref T9
\includelineno Drivers/Tutorials/Tutorial9.cpp
Return to tutorial \ref T9

\section T11code Axisymmetric walls inside a cylindrical domain (code)
Return to tutorial \ref T11
\includelineno Drivers/Tutorials/Tutorial11.cpp
Return to tutorial \ref T11

\section T12code Prismatic walls using points (code)
Return to tutorial \ref T12
\includelineno Drivers/Tutorials/Tutorial12.cpp
Return to tutorial \ref T12

\section CoilSelfTestCode Particles driven by a rotating coil (code)
Return to tutorial \ref CoilSelfTest
\dontinclude Drivers/SelfTests/Walls/CoilSelfTest.cpp
\skip #include
\until the end
Return to tutorial \ref CoilSelfTest

\section ChuteDemoCode Particles on an inclined chute (code)
Return to tutorial \ref ChuteDemo
\dontinclude Drivers/ChuteDemos/ChuteDemo.cpp
\skip #include
\until the end
Return to tutorial \ref ChuteDemo

\section RoughBottomDemoCode Particles on a chute with a multilayered bottom (code)
Return to tutorial \ref RoughBottomDemo
\dontinclude Drivers/ChuteDemos/roughBottomDemo.cpp
\skip #include
\until the end
Return to tutorial \ref RoughBottomDemo

\section IsoCompressionCode Isotropic compression of a cuboidal REV (code)
Return to tutorial \ref IsoCompression
\includelineno Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp
Return to tutorial \ref IsoCompression

\section PureShearCode Pure shear (constant volume) of a cuboidal REV (code)
Return to tutorial \ref PureShear
\includelineno Drivers/MercurySimpleDemos/REVPureShearDemo.cpp
Return to tutorial \ref PureShear

\section SimpleShearCode Simple shear (constant stress) of a cuboidal REV (code)
Return to tutorial \ref SimpleShear
\includelineno Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp
Return to tutorial \ref SimpleShear

\page WallTypes Different types of walls
Walls are crucial in most of our problem setups and hence we have a variety of walls to suit the needs of our users.
\section InfWall Infinite Wall
\image html Walls/infiniteWall.jpg Infinite wall
A standard wall is a plane defined  as {x: normal*x=position}, with normal being the outward unit normal vector of the wall. A particle touches a standard wall if position-normal*x<=radius. Given the normal, a wall can be placed at any given position.\n
The black strip denotes the inner side of the wall. The particles interact with the wall along the blue strip.
\section FinWall Finite Wall
\image html Walls/finiteWall.jpg A block of wall formed by set of infinite walls.
Finite wall is basically a set of infinite walls or A finite wall is convex polygon defined by a set of normals normal_i and positions position_i. For example, to create a polygonal obstacle (in 2D or 3D), we consider the a set of infinite walls and create the obstacle as an intersection of all the infinite walls. See above figure corresponding to finite walls.


*/

/*! \page AdvancedTutorials Advanced tutorials
\section AdvancedOverview Overview

The directories Drivers/MercurySimpleDemos and Drivers/ChuteDemos contain many demo codes that
illustrate the commonly used features of MercuryDPM:\n\n

\b MercurySimpleDemos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage CoilSelfTest <td> \ref CoilSelfTest.cpp
    <td> \ref Coil
<tr><td>\subpage HourGlass2DDemo <td> \ref HourGlass2DDemo.cpp
    <td> \ref IntersectionOfWalls
<tr><td>\subpage HourGlass3DDemo <td> \ref HourGlass3DDemo.cpp
    <td> \ref AxisymmetricIntersectionOfWalls <br> \ref LinearViscoelasticFrictionSpecies
<tr><td>\subpage FreeCoolingDemo <td> \ref FreeCoolingDemo.cpp
    <td> \ref PeriodicBoundary (2D)  <br> Homogeneous and inhomogeneous clustering regimes (2D) <br> Theoretical and Numerical Comparisions
<tr><td>\subpage FreeCooling2DinWallsDemo <td> \ref FreeCooling2DinWallsDemo.cpp
    <td> \ref InfiniteWall (2D)  <br> Homogeneous and inhomogeneous clustering regimes (2D) <br> Experimental and Numerical Comparisions
<tr><td>\subpage FreeCooling3DDemo <td> \ref FreeCooling3DDemo.cpp
    <td> \ref PeriodicBoundary (3D)  <br> Homogeneous and inhomogeneous clustering regimes (3D) <br> Theoretical and Numerical Comparisions
<tr><td>\subpage FreeCooling3DinWallsDemo <td> \ref FreeCooling3DinWallsDemo.cpp
    <td> \ref InfiniteWall (3D)  <br> Homogeneous and inhomogeneous clustering regimes (3D) <br> Experimental and Numerical Comparisions
</table>



\b ChuteDemos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage ChuteDemo <td> \ref ChuteDemo.cpp
    <td> \ref Chute
<tr><td>\subpage RoughBottomDemo <td> \ref roughBottomSelfTest.cpp
    <td> \ref ChuteBottom
<tr><td>\subpage ChuteWithHopper <td> \ref HopperSelfTest.cpp
    <td> \ref ChuteWithHopper
</table>


\b Coarse-Grain Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage FiveParticles <td> \ref FiveParticles.cpp
    <td> \ref Coil
<tr><td>\subpage LeesEdwards <td> \ref LeesEdwardsSelfTest.cpp
        <td> \ref LeesEdwardsBoundary
</table>

\b Sintering Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage SinteringDemos <td> \ref SinterPair.cpp
    <td> \ref Sinter
</table>

\b Deformations in a representative element volume \b (REV) Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage IsoCompression <td> \ref REVIsotropicCompressionDemo.cpp
    <td> \ref StressStrainControlBoundary
<tr><td>\subpage PureShear <td> \ref REVPureShearDemo.cpp
        <td> \ref StressStrainControlBoundary
<tr><td>\subpage SimpleShear <td> \ref REVSimpleShearDemo.cpp
        <td> \ref StressStrainControlBoundary
</table>

\b Parameter study Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage ParameterStudy1D <td> \ref ParameterStudy1DDemo.cpp
    <td> \ref DPMBase::autoNumber()
<tr><td>\subpage ParameterStudy2D <td> \ref ParameterStudy2DDemo.cpp
    <td> \ref DPMBase::autoNumber()
<tr><td>\subpage ParameterStudy3D <td> \ref ParameterStudy3DDemo.cpp
    <td> \ref DPMBase::autoNumber()
<tr><td>\subpage ProtectiveWall <td> \ref ProtectiveWall.cpp
        <td> \ref DPMBase::autoNumber()
</table>


\b Parallelisation Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage openmpDemo <td> \ref FreeCooling2DinWallsDemo.cpp
    <td> \ref OpenMP Parallelisation
<tr><td>\subpage mpiDemo <td> \ref testDrum.cpp
    <td> \ref MPI Parallelisation
<tr><td>\subpage parallelInputOutputDemo <td> \ref HourGlass2DDemoMPI.cpp
    <td> \ref MPI-IO Parallelisation
</table>\n


\page CoilSelfTest Particles driven by a rotating coil

#### Problem description:
This tutorial simulates particle flows around a coil for a short time. The code can be found in \b CoilSelfTest.cpp. It treats particles placed in a feeder being driven forward by a rotating coil.

### Headers
The following headers are included:
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:headers
These are basically the headers used for the beginner tutorials, except for the additional Coil class.

### Before the main function

CoilSelfTest, like many of the previous tutorials, inherits from the Mercury3D class.
\code class CoilSelfTest : public Mercury3D \endcode
The different components of the class will be explained in turn in the following.

step 1: Define Walls\n
The particles are initially contained by a container made up of six walls, five of which are defined to be infinite. The wall in the positive Z-direction is different. Its normal is set (<tt>rightWall->set(...</tt>) in the positive Z-direction (<tt>Vec3D(0, 0, 1)</tt>), is set a distance \c zMax_ (which is returned by <tt>getZMax()</tt>) from the origin, and contains a 'hole' (which is practically a horizontal tube, since the wall is 'infinite') around the X-axis of radius \c 1.0 in order to let the particles through.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:walls

step 2: Coil\n
After that the Coil object is added. Its geometrical properties are subsequently set by using the Coil::set() method, specifying its starting position (the origin, i.e. <tt>Vec3D(0,0,0)</tt>), its length (<tt>1.0</tt>), its radius (<tt>1.0 - particleRadius</tt>), its number of turns (<tt>2.0</tt>), its rotation speed (<tt>-1.0</tt> revelations per second) and its thickness (<tt>0.5 * particleRadius</tt>). \n
NB: its direction or central axis is not specified, since these are the Z-direction and the Z-axis, respectively, by default.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:coil

step 3: Create Particles\n
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the previously set species is assigned to it. The particle is assigned a zero velocity and the previously defined particle radius.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:particle

step 4: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a rectangular grid pattern, on evenly spaced positions. First, the number of particles that fit in each direction is computed. Then, a triple for-loop passes every possible particle position, and a particle is placed on the position if there's no part of the coil there.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:placeparticles

Data members:\n
CoilSelfTest only has two (public) data members, namely a pointer to the coil:
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:datamembers

Actions Before TimeStep:\n
The \b actionsBeforeTimeStep() method specifies all actions that need to be performed at the beginning of each time step, i.e. \a before the actual numerical solution at that time step is computed. In this case, it states that from 1 second into the simulation time and onward, the coil should turn with the given rotational speed.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:beforetime

### Main Function
In the main program, a CoilSelfTest object is created, after which some of its basic properties are set like its number of dimensions (three), time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:main

Next, the particle species is defined. The particles in this problem will use a linear visco-elastic (normal) contact model.
The dissipation and stiffness defining the contact model can be set in different ways. In this example the contact model properties are set by giving a collision time, coefficient of restitution and the particle mass.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:species

### Reference:
<a href="https://www.sciencedirect.com/science/article/pii/S0032591016301206?via%3Dihub"> Imole, O. I., Krijgsman, D., Weinhart, T., Magnanimo, V., Montes, B. E. C., Ramaioli, M., & Luding, S. (2016). Reprint of" Experiments and discrete element simulation of the dosing of cohesive powders in a simplified geometry". Powder technology, 293, 69-81.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page HourGlass2DDemo Flow through a 2D hourglass/silo

<img src="HourGlass2DDemo.png" align="right">

#### Problem description:
A 3D hour glass/silo is simulated, i.e. a square domain with a neck in the middle (see snapshot on the right).
Particles are inserted into the upper half of the domain and flow into the lower half due to gravity.

Here a short paraview animation of the code's output.
\htmlonly
<br><iframe width="420" height="315" src="https://www.youtube.com/embed/IQSn1Yv47l4" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

This code illustrates the effect of friction in DPM simulations. If the friction is high enough, arching is observed at the neck, where particles interlock to obstruct the flow.
It also illustrates how to use IntersectionOfWalls to set up a convex polygonal wall, i.e. the neck.

### Defining an intersection of walls
The neck is defined by two IntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass2DDemo.cpp CST:neck


(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page HourGlass3DDemo  Flow through a 3D hourglass/silo

<img src="HourGlass3DDemo.png" align="right">

#### Problem description
A 3D hour glass/silo is simulated, i.e. a cylindrical domain with a neck in the middle (see snapshot on the right).
Particles are inserted into the upper half of the domain and flow into the lower half due to gravity.

Here a short paraview animation of the code's output.
\htmlonly
<br><iframe width="420" height="315" src="https://www.youtube.com/embed/2QxP2MT2TVo" frameborder="0" allowfullscreen></iframe>
\endhtmlonly


This code illustrates the effect of friction in DPM simulations. If the friction is high enough, arching is observed at the neck, where particles interlock to obstruct the flow.
It also illustrates how to use AxisymmetricIntersectionOfWalls to set up axisymmetrical shapes, i.e. the outer cylinder and the neck.

### Defining an axisymmetric wall
The outer wall is defined by an AxisymmetricIntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass3DDemo.cpp CST:outer
The neck is also defined by an AxisymmetricIntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass3DDemo.cpp CST:neck

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page FreeCoolingDemo Free cooling granular system (2D)

#### Model/Simulation:
In this tutorial, the homogeneous and inhomogeneous regimes of a free cooling granular system (2D) are simulated [1]. 
This model is common in the study of the kinetic theory of granular gases [2-3]. For a 3D version of this code, see \ref FreeCooling3DDemo. 

#### Description:
Granular gasses are particulate systems in which the mean free path of the particles is greater than the typical particle size. 
Free cooling is the study of how a granular gas behaves when no external forces are applied. Such a free cooling model is characterized 
by a decay in kinetic energy. This decay of kinetic energy is due to effects such as dissipation during particle collisions, the formation of clusters, 
anomalous diffusion and characteristic shock waves, to name but a few [3].


Here, a short paraview animation of the free cooling demo is shown.
\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/5J-GUoTMNqk" frameborder="0" allowfullscreen></iframe>
\endhtmlonly


#### Simulation set up:

To simulate the free cooling of a granular gas in 2D, particles are inserted into a square box, with periodic boundary conditions in both dimensions. 
First, a well-defined initial state with random particle positions and velocities is prepared in the following way: 

1. The particles first sit on a regular lattice and get a random velocity with a total momentum of zero. 
2. Then the simulation is started without dissipation and runs for a reasonable number of collisions per particle so that the system becomes homogeneous, "and the velocity distribution approaches
a Maxwellian." 
3. The above state is then used as the initial configuration for the dissipative regimes.


#### About the code 

First, we need to include the following headers: 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:headers

Then, we define a new class \ref FreeCoolingDemo. Because we want to run 2D simulations, this class inherits from the \ref Mercury2D class. 
\code class FreeCoolingDemoProblem : public Mercury2D \endcode 


#### Data members of the class:\n 
The FreeCoolingDemo class has, but is not limited to, two (public) data members, namely a pointer to the species and number of particles 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:datamembers.

The key components of the class are explained in-turn, in the following:

Step 1: Define Walls/Periodic Boundaries\n
For experimental purposes, particles can be contained by a two dimensional box made up of four infinite walls. 
If this is required, then see the \ref FreeCooling2DinWallsDemo. Otherwise, the simulation volume is replaced by periodic boundaries. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:walls

Step 2: Create Particles\n
Next, the particle species is defined. The particles in this problem use the linear visco-elastic (normal) contact model (\ref LinearViscoelasticSpecies).
The dissipation and stiffness defining the contact model can be set in different ways. In this example these contact model parameters are defined. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:species
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the set species is assigned to it. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:particle

Step 3: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a lattice grid pattern, on evenly spaced positions. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:placeparticles


Step 4: Centre of mass velocity\n
Next, the center of mass velocity is subtracted to ensure a reduced random velocity. This results into a center of mass velocity nearly equal to zero. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:CO_Mass


Actions After TimeStep:\n
The \b actionsAfterTimeStep() method specifies all actions that need to be performed in between time steps, i.e. \a Since, the simulation started with zero dissipation, after a reasonable number of collisions per particle, the system will be homogeneous, and
the \b actionsAfterTimeStep() is used to set the initial configuration for the "next" dissipative regime. 
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:aftertime

### Main Function
In the main program, the FreeCoolingDemo object is created, after which some of its basic properties are set: like, the number of particles, box dimensions, time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/FreeCoolingDemo.cpp FCD_2D:main


### References:

1. <a href="https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_cluster.pdf"> Luding, S. (2005). Structure and cluster formation in granular media. Pramana, 64(6), 893-902.</a>


2. Brilliantov, N. V., & Pöschel, T. (2010). Kinetic theory of granular gases. Oxford University Press.

3. Pöschel, T., & Luding, S. (Eds.). (2001). Granular gases (Vol. 564). Springer Science & Business Media

(Return to \ref AdvancedOverview "Overview of advanced tutorials")



\page FreeCooling2DinWallsDemo Free cooling granular system (2D) in walls

#### Description:

This tutorial is used to simulate the homogeneous and inhomogeneous regimes of a free cooling granular system (2D) contained in a square box (four infinite walls, \ref InfiniteWall). 
It mimics a laboratory model for the experimenting the behaviour of granular gases. For a 3D version of this code, see \ref FreeCooling3DinWallsDemo. 

The animation below shows the free cooling granular system/particles contained in a square (2D) box.
\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/rJOaQExhOI8" frameborder="0" allowfullscreen></iframe>
\endhtmlonly


#### Simulation set up:

Particles are inserted into a square box, with infinite walls in both dimensions. Just like the \ref FreeCoolingDemo, a well-defined initial state with random particle positions and velocities is prepared in the following way: 

1. The particles first sit on a regular lattice and get a random velocity with a total momentum of zero. 
2. Then the simulation is started without dissipation and runs for a reasonable number of collisions per particle so that the system becomes homogeneous, "and the velocity distribution approaches
a Maxwellian." 
3. The above state is then used as the initial configuration for the dissipative regimes.


#### About the code 

First, we need to include the following headers: 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:headers

Then, we define a new class \ref FreeCooling2DinWallsDemo. Again, since we want to run 2D simulations, this class inherits from the \ref Mercury2D class. 
\code class FreeCooling2DinWallsDemo : public Mercury2D \endcode 


#### Data members of the class:\n 
The FreeCooling2DinWallsDemo class has, but is not limited to, two (public) data members, namely a pointer to the species and number of particles 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:datamembers

The key components of the class are explained in-turn, in the following:

Step 1: Define Walls/Periodic Boundaries\n
The particles are the inserted in a two dimensional box made up of four infinite walls.  
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:walls

Step 2: Create Particles\n
Now, the particle species is defined. The particles in this problem use the linear visco-elastic (normal) contact model (\ref LinearViscoelasticSpecies).
The dissipation and stiffness defining the contact model can be set in different ways. In this example these contact model parameters are defined. 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:species
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the set species is assigned to it. 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:particle

Step 3: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a lattice grid pattern, on evenly spaced positions. 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:placeparticles


Step 4: Centre of mass velocity\n
Next, the center of mass velocity is subtracted to ensure a reduced random velocity. This results into a center of mass velocity nearly equal to zero. 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:CO_Mass


Actions After TimeStep:\n
The \b actionsAfterTimeStep() method specifies all actions that need to be performed in between time steps, i.e. \a Since, the simulation started with zero dissipation, after a reasonable number of collisions per particle, the system will be homogeneous, and
the \b actionsAfterTimeStep() is used to set the initial configuration for the "next" dissipative regime. 
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:aftertime

### Main Function
In the main program, the FreeCooling2DinWallsDemo object is created, after which its basic properties are set: like, the number of particles, box dimensions, time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp FCD_2D_Walls:main


### References:

1. <a href="https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_cluster.pdf"> Luding, S. (2005). Structure and cluster formation in granular media. Pramana, 64(6), 893-902.</a>

2. Brilliantov, N. V., & Pöschel, T. (2010). Kinetic theory of granular gases. Oxford University Press.

3. Pöschel, T., & Luding, S. (Eds.). (2001). Granular gases (Vol. 564). Springer Science & Business Media

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page FreeCooling3DDemo Free cooling granular system (3D)

#### Model/Simulation:
The homogeneous and inhomogeneous regimes of a free cooling granular system (3D) are simulated. Just like the \ref FreeCoolingDemo, particles are initially randomized with a large kinetic energy and collisions occur dissipatively. 
This model is common in the study of the kinetic theory of granular gases [1-3].

Below, a short paraview animation of the 3D free cooling demo is shown.

\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/sjpNRJ34iH4" frameborder="0" allowfullscreen></iframe>
\endhtmlonly


#### Simulation set up:

In the animation, the simulation volume consists of a box with equal side length and periodic boundary conditions in three dimensions (3D). Just like the 2D demo case (\ref FreeCoolingDemo), the initial state with random particle positions and velocities is prepared in the following way: 

1. The particles first sit on a regular lattice and get a random velocity with a total momentum of zero. 
2. Then the simulation is started without dissipation and runs for a reasonable number of collisions per particle so that the system becomes homogeneous, "and the velocity distribution approaches
a Maxwellian." 
3. The above state is then used as the initial configuration for the dissipative regimes.


The FreeCooling3DDemo class inherits from the Mercury3D class.
\code class FreeCooling3DDemoProblem : public Mercury3D \endcode


Thus, the following headers are included:
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:headers 

#### Data members of the class:\n
The FreeCooling3DDemo class has, but not limited to two (public) data members, namely a pointer to the species and the number of particles:
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:datamembers

The key components of the class are explained in-turn, in the following:

step 1: Define Walls/Periodic Boundaries\n
For experimental purposes, particles can be contained by a three dimensional box made up of six infinite walls. If this is required, then please see the \ref FreeCooling3DinWallsDemo. Otherwise, the simulation volume is replace by periodic boundaries. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:walls

step 2: Create Particles\n
Next, the particle species is defined. The particles in this problem use a linear visco-elastic (normal) contact model.
The dissipation and stiffness defining the contact model can be set in different ways. In this example these contact model parameters are defined. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:species
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the set species is assigned to it. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:particle

step 3: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a lattice grid pattern, on evenly spaced positions. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:placeparticles


step 4: Centre of mass velocity\n
Next, the center of mass velocity is subtracted to ensure a reduced random velocity. This results into a center of mass velocity nearly equal to zero. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:CO_Mass


Actions After TimeStep:\n
The \b actionsAfterTimeStep() method specifies all actions that need to be performed in between time steps, i.e. \a Since, the simulation started with zero dissipation, after a reasonable number of collisions per particle, the system will be homogeneous, and
the \b actionsAfterTimeStep() is used to set the initial configuration for the "next" dissipative regime. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:aftertime

### Main Function
In the main program, the FreeCooling3DDemo object is created, after which some of its basic properties are set: like, the number of particles, box dimensions, time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/FreeCooling3DDemo.cpp FCD_3D:main


### References:

1. <a href="https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_cluster.pdf"> Luding, S. (2005). Structure and cluster formation in granular media. Pramana, 64(6), 893-902.</a>

2. Brilliantov, N. V., & Pöschel, T. (2010). Kinetic theory of granular gases. Oxford University Press.

3. Pöschel, T., & Luding, S. (Eds.). (2001). Granular gases (Vol. 564). Springer Science & Business Media

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page FreeCooling3DinWallsDemo Free cooling granular system (3D) in walls



#### Description:

This tutorial is used to simulate homogeneous and inhomogeneous regimes of a free cooling granular system/particles contained in a cubic box (six infinite walls, \ref InfiniteWall).
For detailed descriptions about the free cooling granular systems see references [1-3].    

Here, a short paraview animation of the 3D free cooling demo is shown.

\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/qC1p6rk4LZU" frameborder="0" allowfullscreen></iframe> 
\endhtmlonly


#### Simulation set up:

In the animation, the simulation volume consists of a box with equal side length in 3D. Just like other free cooling demo tutorials, the initial state with random particle positions and velocities is prepared in the following way: 

1. The particles first sit on a regular lattice and get a random velocity with a total momentum of zero. 
2. Then the simulation is started without dissipation and runs for a reasonable number of collisions per particle so that the system becomes homogeneous, "and the velocity distribution approaches
a Maxwellian." 
3. The above state is then used as the initial configuration for the dissipative regimes.


The FreeCooling3DinWallsDemo class inherits from the Mercury3D class.
\code class FreeCooling3DinWallsDemo : public Mercury3D \endcode


Thus, the following headers are included:
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:headers 

#### Data members of the class:\n
The FreeCooling3DinWallsDemo class has, but not limited to two (public) data members, namely a pointer to the species and number of particles:
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:datamembers

The key components of the class are explained in-turn, in the following:

step 1: Define Walls\n
Particles can be contained by a three dimensional box made up of six infinite walls. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:walls

step 2: Create Particles\n
Next, the particle species is defined. The particles in this problem use a linear visco-elastic (normal) contact model.
The dissipation and stiffness defining the contact model can be set in different ways. In this example these contact model parameters are defined. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:species
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the set species is assigned to it. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:particle

step 3: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a lattice grid pattern, on evenly spaced positions. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:placeparticles


step 4: Centre of mass velocity\n
Next, the center of mass velocity is subtracted to ensure a reduced random velocity. This results into a center of mass velocity nearly equal to zero. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:CO_Mass


Actions After TimeStep:\n
The \b actionsAfterTimeStep() method specifies all actions that need to be performed in between time steps, i.e. \a Since, the simulation started with zero dissipation, after a reasonable number of collisions per particle, the system will be homogeneous, and
the \b actionsAfterTimeStep() is used to set the initial configuration for the "next" dissipative regime. 
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:aftertime

### Main Function
In the main program, the FreeCooling3DinWallsDemo object is created, after which some of its basic properties are set: like, the number of particles, box dimensions, time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/FreeCooling3DinWallsDemo.cpp FCD_3D_inWalls:main


### References:

1. <a href="https://www2.msm.ctw.utwente.nl/sluding/PAPERS/luding_cluster.pdf"> Luding, S. (2005). Structure and cluster formation in granular media. Pramana, 64(6), 893-902.</a>

2. Brilliantov, N. V., & Pöschel, T. (2010). Kinetic theory of granular gases. Oxford University Press.

3. Pöschel, T., & Luding, S. (Eds.). (2001). Granular gases (Vol. 564). Springer Science & Business Media

(Return to \ref AdvancedOverview "Overview of advanced tutorials")



\page ChuteDemo Particles on an inclined chute
#### Problem description
%File \b ChuteDemo.cpp treats particles cascading down an inclined chute. The entire code of this problem can be viewed here: \ref ChuteDemoCode.

\htmlonly
<video src="chutedemo_compressed.ogv" id="movie" controls height="240"> henk </video>
\endhtmlonly

### Headers
The following headers are included:
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:include
The particle species is manually set here, and therefore needs to be included. We're treating a chute problem here, and the Chute class needs to be included therefore as well. The particles, walls and boundaries classes are already implemented by the chute class and don't need inclusion here.

### <tt> int %main()</tt>
Since the whole structure of the problem is already implemented in the Chute class, no separate class needs to be set up. The setup of initial conditions of the Chute class is shortly treated at \ref ChuteSetupInitialConditions "the end of this section". \n

The main driver program starts by initialising a Chute object. Next, the most basic problem properties are set, namely its name (which determines the naming of the data output files), save count (which is the number of time steps skipped between every saved one), particle
collision time (which is a species property, but also used in setting the time step), time step and maximum time. Note, that the total number of time steps saved to the output files is not directly set, but is equal to the maximum time divided by time step size \a and save count.

\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:initial

\n
Next, the particle properties are set. \c setFixedParticleRadius() sets the radius of the fixed chute bottom particles, while \c setInflowParticleRadius() sets the inflow particles to be monidisperse with the given particle radius. If inflow particles with random radii are desired, \c setMinInflowParticleRadius() and \c setMaxInflowParticleRadius() can be used instead to set the minimum and maximum particle radius, respectively. \n
The particle species (i.e. its intrinsic material properties) are set next, by specifying the density (<tt>species.setDensity()</tt>) and
the characteristic collision time and coefficient of restitution (with a typical particle mass given; <tt>species.setCollisionTimeAndRestitutionCoefficient(\f$ t_c, r_c, m\f$)</tt>).

\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:particles

\n
The chute properties are subsequently set by specifying the chute's length, width and angle relative to the horizontal.
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:chute

\n
The chute inflow parameters (besides the previously set inflow particle properties) are set by specifying the inflow height (in Z-direction), the mean iflow particle velocity (in X-direction), and the particle velocity variance (in ratio of the mean velocity).
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:inflow

\n
After all the problem parameters are specified, the simulation is run by calling the \b solve() method.
\code problem.solve(); \endcode

### \anchor ChuteSetupInitialConditions Chute::setupInitialConditions()

\dontinclude Kernel/Chute.cc
\skip InitialConditions()
\until }

The setup of initial conditions of the Chute class starts by checking for the presence of a species, and returns an error if there is none. Make sure therefore that you assign a species to the Chute object's \b speciesHandler before you call the \b solve() method. \n
After that, the side walls (in the Y-direction) are set up by calling Chute::setSideWalls(). These are set to be solid, infinite walls by default, but can be set to be \a periodic instead by setting Chute::isChutePeriodic_ to be \b true. \n
A particle is then created (on the \a heap) which is assigned the first (and only) species in the speciesHandler which we earlier specified in the driver (\b ChuteDemo.cpp).\n
A ChuteInsertionBoundary is created, and its parameters subsequently set by its \b set() method. The set() method arguments are, respectively:
- \c p: the previously specified particle
- \c maxFailed_: internally used parameter
- <tt> Vec3D(getXMin(), getYMin(), getZMin())</tt>: the first defining corner of the cuboidal insertion boundary
- <tt> Vec3D(getXMax(), getYMax(), getZMax())</tt>: the second defining corner of the cuboidal insertion boundary
- \c min- / \c maxInflowParticleRadius_: the minimum and maximum radii of inflow particles
- \c fixedParticleRadius_: the particle radius making up the chute bottom
- \c inflowVelocity(Variance)_: the mean velocity of inflow particles and the allowed variance about the mean

After setting the insertion boundary characteristics, it is added to the problem's \b boundaryHandler. \n
Lastly, the chute's bottom is created. The \a type of bottom created may be set by calling the Chute::setRoughBottomType() method in the driver, giving either of the following four arguments (which are of type \c enum \c RoughBottomType):
- FLAT: just a flat wall (of the species given in the driver)
- MONOLAYER_ORDERED: (a single layer of) fixed particles in a rectangular grid pattern
- MONOLAYER_DISORDERED: (\b default) a single layer of randomly placed particles
- MULTILAYER: a few layers of randomly placed particles, with a random variation in vertical position as well

### Reference:
<a href="https://link.springer.com/article/10.1140%2Fepje%2Fi2012-12127-5"> Thornton, A. R., Weinhart, T., Luding, S., & Bokhove, O. (2012). Frictional dependence of shallow-granular flows from discrete particle simulations. The European Physical Journal E, 35(12), 127.</a>\n
<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0355-y">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). Closure relations for shallow granular flows from particle simulations. Granular matter, 14(4), 531-552.</a>


(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page RoughBottomDemo Particles on a chute with a multilayered bottom

#### Problem description:
%File \b roughBottomDemo.cpp treats particles cascading down an inclined chute with a rough bottom consisting of multiple layers of fixed particles. The entire code of this problem can be viewed here: \ref RoughBottomDemoCode.

### Headers
\snippet Drivers/ChuteDemos/roughBottomSelfTest.cpp RB:headers

### Before the main function
### Main function
\snippet Drivers/ChuteDemos/roughBottomSelfTest.cpp RB:main

### Reference:
<a href="https://link.springer.com/article/10.1140%2Fepje%2Fi2012-12127-5"> Thornton, A. R., Weinhart, T., Luding, S., & Bokhove, O. (2012). Frictional dependence of shallow-granular flows from discrete particle simulations. The European Physical Journal E, 35(12), 127.</a>\n
<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0355-y">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). Closure relations for shallow granular flows from particle simulations. Granular matter, 14(4), 531-552.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page ChuteWithHopper Chute with hopper

#### Problem description:

\ref Hopper3dDemo.cpp treats particles which flow from a hopper onto an inclined chute below. The entire code of this problem can be viewed here: \ref RoughBottomDemoCode.

### Headers
\snippet Drivers/ChuteDemos/HopperSelfTest.cpp CH:headers
### Before the main function
### Main function
\snippet Drivers/ChuteDemos/HopperSelfTest.cpp CH:main

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page FiveParticles Five Particles

#### Problem description:

This tutorial presents five particles positioned on a irregular base made from five fixed particles. The system is nondimensionalised such that particle diameter d = 1, particle mass m = 1 and gravity g = 1.
The code can be found in \ref FiveParticles.cpp.

\image html Tutorials/CG/FiveParticles.jpg Snapshot of the final state of the Five Particles simulation (left). Coarse-graining is applied to obtain the bulk density ρ (centre) and pressure p (right).

### Headers
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:headers

### Before the main function
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:class
### Main function
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:main

### Reference:

<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0317-4">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). From discrete particles to continuum fields near a boundary. Granular Matter, 14(2), 289-294.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page LeesEdwards Lees Edward

#### Problem description:

Now we study a more complex situation, in which a continuum formulation makes sense: granular media sheared at a constant rate
The code can be found in \ref LeesEdwardsSelfTest.cpp.

\image html Tutorials/Shear/Lees.jpg Granular media sheared.

### Headers
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:headers

### Before the main function
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:class

### Main function
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:main

### Reference:
<a href="https://iopscience.iop.org/article/10.1088/0022-3719/5/15/006/meta">Lees, A. W., & Edwards, S. F. (1972). The computer study of transport processes under extreme conditions. Journal of Physics C: Solid State Physics, 5(15), 1921.</a>\n
<a href="https://ris.utwente.nl/ws/portalfiles/portal/20335358/granular.pdf">Granular Flow: From Dilute to Jammed States.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page SinteringDemos Simple sintering process

#### Problem description:
This tutorial present a simple case of sintering between two particles. The code can be found in \ref SinterPair.cpp.

\image html Tutorials/Sintering/Sintering.jpg Sintering of two particles.

### Headers
\snippet Drivers/Sinter/SinterPair.cpp St:headers

### Before the main function
\snippet Drivers/Sinter/SinterPair.cpp St:class

### Main function
There are three different radii for this tutorial: 1.5e-6, 2.0e-6, 5.0e-7

\snippet Drivers/Sinter/SinterPair.cpp St:main

### Reference:
<a href="https://www.epj-conferences.org/articles/epjconf/abs/2017/09/epjconf162460/epjconf162460.html">Fuchs, R., Weinhart, T., Ye, M., Luding, S., Butt, H. J., & Kappl, M. (2017). Initial stage sintering of polymer particles–Experiments and modelling of size-, temperature-and time-dependent contacts. In EPJ Web of Conferences (Vol. 140, p. 13012). EDP Sciences.</a>


(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page IsoCompression Isotropic compression of a cuboidal REV

#### Problem description
This tutorial presents how to use the \ref StressStrainControlBoundary to achieve isotropic compression in a 3D cuboidal representative element volume.
The particle bed is initially inserted into the box in a loose packing and then isotropically compressed using a constant strainrate control.

Here a short video of the code's output.
\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/tCnbVvWyOek" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp REV_ISO:headers
These are the necessary headers to be included.

### Before the main function

Isotropic compression, like many of the previous tutorials, inherits from the Mercury3D class. \n
\code class StressStrainControl : public Mercury3D \endcode
The different components of the class will be explained in turn in the following.

Step 1: Define the constructor: \n
Here we first define the constructor that contains user inputs (target stress, strainrate, gainFactor and the switch Boolean key for strainrate control on particle movements) which will be inserted later on in the main function. Then we define here also the domain size and specie. \n
\snippet Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp REV_ISO:construct

Step 2: Set up initial conditions: \n
Here we setup the system dimensions, timestepping and gravity, then add particles using the CubeInsertionBoundary. After we inserted 96 particles, we then setup the StressStrainControlBoundary using user inputs. For the current case, the final boundary consists of 3 Periodic boundaries in x, y, z directions, respectively. \n
\snippet Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp REV_ISO:setIni

Step 3: Declare private data members: \n
REV_IsotropicCompression has three \b Matrix3D variables and one Boolean variable. These variables are used to pass the user inputs via the constructor. \n
\snippet Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp REV_ISO:datamembers

### Main Function

In the main function, we first define the target stress tensor, strainrate tensor, gainFactor tensor (only used if stress tensor is non-zero), and the boolean variable isStrainRateControlled. \n
Then a StressStrainControl object is created, after which some of its basic properties are set like its name, saveCount and outputs ON/OFF. Finally, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/REVIsotropicCompressionDemo.cpp REV_ISO:main

### Reference:
<a href="https://www.jstage.jst.go.jp/article/kona/30/0/30_2013011/_article"> Imole, O. I., Kumar, N., Magnanimo, V., & Luding, S. (2013). Hydrostatic and shear behavior of frictionless granular assemblies under different deformation conditions. KONA Powder and Particle Journal, 30, 84-108.</a>

If you would like to know more about the definitions used in the StressStrainControlBoundary and various deformation possibilities,
please click here (right click and open in a new tab if left click does not work): <a href="../../../Documentation/AdditionalDocumentation/StressStrainControlBoundary.pdf"> StressStrainControlBoundary.pdf </a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page PureShear Pure shear (constant volume) of a cuboidal REV

#### Problem description
This tutorial presents how to use the \ref StressStrainControlBoundary to achieve volume conserving pure shear in a 3D cuboidal representative element volume.
The particle bed is initially inserted into the box in a loose packing and then dilated in x direction and compressed in y direction using a constant strainrate control.

Here a short video of the code's output.
\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/Egk16RW2Ur8" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/REVPureShearDemo.cpp REV_PUR:headers
These are the necessary headers to be included.

### Before the main function

Like the previous example of isotropic compression, pure shear also inherits from the Mercury3D class. \n
\code class StressStrainControl : public Mercury3D \endcode
The different components of the class will be explained in turn in the following.

Step 1: Define the constructor: \n
Here we first define the constructor that contains user inputs (target stress, strainrate, gainFactor and the switch Boolean key for strainrate control on particle movements) which will be inserted later on in the main function. Then we define here also the domain size and specie. \n
\snippet Drivers/MercurySimpleDemos/REVPureShearDemo.cpp REV_PUR:construct

Step 2: Set up initial conditions: \n
Here we setup the system dimensions, timestepping and gravity, then add particles using the CubeInsertionBoundary. After we inserted 96 particles, we then setup the StressStrainControlBoundary using user inputs. For the current case, the final boundary consists of 3 Periodic boundaries in x, y, z directions, respectively. \n
\snippet Drivers/MercurySimpleDemos/REVPureShearDemo.cpp REV_PUR:setIni

Step 3: Declare private data members: \n
REV_IsotropicCompression has three \b Matrix3D variables and one Boolean variable. These variables are used to pass the user inputs via the constructor. \n
\snippet Drivers/MercurySimpleDemos/REVPureShearDemo.cpp REV_PUR:datamembers

### Main Function

In the main function, we first define the target stress tensor, strainrate tensor, gainFactor tensor (only used if stress tensor is non-zero), and the boolean variable isStrainRateControlled. \n
Then a StressStrainControl object is created, after which some of its basic properties are set like its name, saveCount and outputs ON/OFF. Finally, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/MercurySimpleDemos/REVPureShearDemo.cpp REV_PUR:main

### Reference:
<a href="https://www.jstage.jst.go.jp/article/kona/30/0/30_2013011/_article"> Imole, O. I., Kumar, N., Magnanimo, V., & Luding, S. (2013). Hydrostatic and shear behavior of frictionless granular assemblies under different deformation conditions. KONA Powder and Particle Journal, 30, 84-108.</a>

If you would like to know more about the definitions used in the StressStrainControlBoundary and various deformation possibilities,
please click here (right click and open in a new tab if left click does not work): <a href="../../../Documentation/AdditionalDocumentation/StressStrainControlBoundary.pdf"> StressStrainControlBoundary.pdf </a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")



\page SimpleShear Simple shear (constant stress) of a cuboidal REV

#### Problem description
Like the previous tutorials, this one demonstrates how the \ref StressStrainControlBoundary works on the simple shear deformation mode.
Here in the example we keep a constant shear rate in x direction while try to maintain a constant stress in y direction.
We generate a loose initial packing by randomly inserting the particles into the cuboid, then tell the boundary
that we need to keep constant shear rate in x direction with a velocity gradient in y direction. We also tell the
boundary that we need to have stress in y direction to reach 100 (the actual unit depends on your scaling of other parameters,
if you use SI-unit, i.e. second, metre, kilogram, for all the other parameters, then the stress will be Pascal)
and be kept there at close as possible to the target value during the shearing. Note that in the current settings,
the particles are following affine movements in a strainrate control. You could also set the strainrate control to false,
then the boundary will drag the particles to move.

Here is a short video of the code's output.
\htmlonly
<br><iframe width="600" height="600" src="https://www.youtube.com/embed/G_RqT8zSMlI" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp REV_SIM:headers
These are the necessary headers to be included, they are the same as the other REV tutorials.

### Before the main function

Like the previous example of isotropic compression, simple shear also inherits from the Mercury3D class. \n
\code class StressStrainControl : public Mercury3D \endcode
The different components of the class will be explained in turn in the following.

Step 1: Define the constructor: \n
Here we first define the constructor that contains user inputs (target stress, strainrate, gainFactor and the switch Boolean key for strainrate control on particle movements) which will be inserted later on in the main function. Then we define here also the domain size and specie. \n
\snippet Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp REV_SIM:construct

Step 2: Set up initial conditions: \n
Here we setup the system dimensions, timestepping and gravity, then add particles using the CubeInsertionBoundary. After we inserted 96 particles, we then setup the StressStrainControlBoundary using user inputs. For the current case, the final boundary consists of 3 Periodic boundaries in x, y, z directions, respectively. \n
\snippet Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp REV_SIM:setIni

Step 3: Declare private data members: \n
REV_IsotropicCompression has three \b Matrix3D variables and one Boolean variable. These variables are used to pass the user inputs via the constructor. \n
\snippet Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp REV_SIM:datamembers

### Main Function

In the main function, we first define the target stress tensor, strainrate tensor, gainFactor tensor (this is associated with the stress control and could be tunned accordingly), and the boolean variable isStrainRateControlled. \n
Then a StressStrainControl object is created, after which some of its basic properties are set like its name, saveCount and outputs ON/OFF. Finally, the problem is actually solved by calling its \b solve() method.

Note that for tuning the gainFactor, if the value is too large, then the stress control correction magnitude is too large, resulting in over correction,
or if it is too small, then the correction per timestep is too small then you never reach the target stress value.
This gain factor is also associated with the shear rate, because the faster you shear, the higher stress difference is created per timestep,
then the corresponding correction on the stress has also to be large. However, one has to bear in mind that if the shear deformation is in
similar magnitude as the stress control magnitude, i.e. you move the particle in both shear (x) and stress control (y) directions in similar displacement per timestep,
it might cause resonance effect resulting in the oscillation in the stress field.

In the current example, we have set the isStrainRateControlled = true, this means we move particles everytime step using affine movement according to the strainrate tensor.
This is because we want to shear everything in a more homogenous way and it will reach steady state faster.
If you choose to use boundary movement dragging the particles, then simply set this boolean to false.

The current setup also moves the boundary with its strainrate control, therefore the volume is not conserving. If user would like to have a constant volume shearing,
simply set the target stress tensor to zero (this case set target stress in y direction to 0).
\snippet Drivers/MercurySimpleDemos/REVSimpleShearDemo.cpp REV_SIM:main

### Reference:
<a href="https://www.jstage.jst.go.jp/article/kona/30/0/30_2013011/_article"> Imole, O. I., Kumar, N., Magnanimo, V., & Luding, S. (2013). Hydrostatic and shear behavior of frictionless granular assemblies under different deformation conditions. KONA Powder and Particle Journal, 30, 84-108.</a>\n
<a href="https://link.springer.com/article/10.1007%2Fs10035-019-0968-5"> Shi, H., Roy, S., Weinhart, T., Magnanimo, V., & Luding, S. (2020). Steady state rheology of homogeneous and inhomogeneous cohesive granular materials. Granular matter, 22(1), 14.</a>

If you would like to know more about the definitions used in the StressStrainControlBoundary and various deformation possibilities,
please click here (right click and open in a new tab if left click does not work): <a href="../../../Documentation/AdditionalDocumentation/StressStrainControlBoundary.pdf"> StressStrainControlBoundary.pdf </a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page ParameterStudy1D Parameter study in 1D parameter space

#### Problem description
This tutorial shows how to do a parameter study by using the \ref autonumber function in DPMBase. This tutorial treats the case in which only a 1D parameter study has to be performed,
for example one wants to study the same setup but for different particle sizes. In the image below a schematic overview is given for a 1D parameter study, This tutorial explains only how to setup a parameter study, for (more) realistic geomtries or complicated setups
one is referred to the other tutorials. \n
Definition of words:\n
Parameter study: The complete set of simulations that needs to be run in which parameters change value based on the dimension set. This is done by creating a exectuable of the complete parameter study
that is capable of starting many simulations. Parameter study is sometimes abreviated to study. \n
Simulation: A single simulation that is part of the parameter study. The simulation is not a distinct executable, but run through the parameter study executable.

\image html Tutorials/ParameterStudy/GridParamStudy1D.png Schematic overview of a 1D parameter study. Definitions of i and dim1 will be given later.

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:headers
These are the headers needed for this tutorial.

## Before the main function
The main class inherits from Mercury3D.\n
\code class ParameterStudy1DDemo: public Mercury3D \endcode
All steps needed in order to create this class are explained below. \n

Step 1: (Private) Member variables. \n
The private member variables are needed in order to keep track of which simulation has to be run next, these are stored in studyNum.
The total amount of simulations that need to be performed are stored in dim1_.
studyNum is build up as follows: \n
The first entry is storing an integer giving information on the completeness of the study. If the value is 0 the parameter study is incomplete, if the value is 1 (or larger) the study is complete. \n
The second entry is storing the current run in the first dimension of the parameter study.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:privMem

Step 2: Set- and Get-functions for private member variables. \n
The set- and get-functions are needed to access the private member variables in the public member functions of ParameterStudy1DDemo.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:setgetFunc

Step 3: Create the particle species. \n
In this case it has been chosen to create a separate function for the particle species. In principle any contact model can be chosen here, but for the sake of
simplicity a simple LinearViscoelasticFrictionSpecies is implemented.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:createSpecies

Step 4: Setup the initial conditions. \n
The initial conditions are run inside the \ref DPMBase::solve() routine. This means that before the actual simulation is started, this function is run first.
This makes us able to do the following things. First we get the studyNum, as we need this information to setup the current simulation.
Also the createSpecies function is called (see Step 3). Afterwards two particles are inserted. Note that in these lines the studyNum is used to change
the particle radius of particle 1. the variable studyNum gets assigned integer values, starting from 1 and ranging to dim1_ (which will be set through main()).
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:setupInit

Step 5: Seting up the parameter study. \n
This is probably the most difficult part of the tutorial, as the previous steps are similar to other tutorials that can be found.
The desire is to create a smart algorithm to decide what simulation runs have to be performed. It might happen that one runs the executable twice in the same directory,
or that you want to extend the previous dimension of your parameter study. In this case the previous simulations do not need to be rerun, as all the data is already known and stored.
Hence in actionsBeforeTimeLoop this is checked by looking for data-files of a certain name as well as checking the studyNum.
If the study is complete the parameter study is done, and hence the process is terminated by the exit code. If the data-file has been found, but
the study is not yet complete the program is taking a short-cut by skipping the current simulation (without rerunning) and starting the next.
\n Please Note: Not all systems use the same syntax to start simulations. For this reason the entry in the functions "launchNewRun(..)" might be slightly different depending on the operating system you use.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:actBefTLoop

If none ot the above options are triggered, in other words the simulation has to be performed, the code is simply run.
At the end of the simulation it is once again checked if the parameter study is completed (the case if this simulation is the last one of the study) or if a new simulation has to be started.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:actAftSolve

Step 6: Creating the main() function
The main function contains some core function calls that setup the parameter study, but also have some information that is the same for each simulation (e.g. the system dimensions).
In principle one could place everything that is equal in all simulations here. Typically one wants to perform a parameter study in which particle properties or contact models are changed, hence these
can be found in the ParameterStudy1DDemo class, it is less likely that the system dimensions need to be changed. If however this is the case for you, simply move the lines
setXMax(), etc. to the setupInitialConditions().
The key line in main() is problem.autonumber(), this creates the file COUNTERDONOTDEL and stores the information needed for the parameter study.
This file should only be deleted in the cases:
The data is backed up in a different directory (as then the executable is no longer able to make changes).\n
One wants to rerun the parameter study completely. \n
The last thing we need to do is to set the dimension os the 1D parameter study, in this case it is set to 4.
This means that in total we want 4 simulations.
\snippet Drivers/MercurySimpleDemos/ParameterStudy1DDemo.cpp PAR_SIM1D:main

If you would like to continue to the 2D or 3D parameter study demos:\n
\ref ParameterStudy2D "ParameterStudy2DDemo" \n
\ref ParameterStudy3D "ParameterStudy3DDemo" \n

Or return to \ref AdvancedOverview "Overview of advanced tutorials"

\page ParameterStudy2D Parameter study in 2D parameter space

#### Problem description
This tutorial is an extension to ParameterStudy1DDemo, and thus also has very similar code structure.
It shows how to do a parameter study by using the \ref autonumber function in DPMBase. This tutorial treats the case in which
a 2D parameter study has to be performed. The difference with ParameterStudy1DDemo is only the addition of the second dimension of the parameter study.
Only the differences with respect to the 1D case are given here, as it is assumed that one looks at ParameterStudy1DDemo first.
In this case ParameterStudy1D is extended to change both particle radii, and thus a parameter space can be created. This parameter space is also visualised
in the image below.

\image html Tutorials/ParameterStudy/GridParamStudy2D.png Schematic overview of a 2D parameter study. Definitions of i, j, dim1 and dim2 will be given later.

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/ParameterStudy2DDemo.cpp PAR_SIM2D:headers
These are the headers needed for this tutorial.

## Before the main function
The main class inherits from Mercury3D.\n
\code class ParameterStudy2DDemo : public Mercury3D \endcode
All steps needed in order to create this class have been explained below.\n

Step 1: (Private) Member variables. \n
Compared to ParameterStudy1DDemo a new variable is added, dim2_, that stores the information of the second dimension of the parameter study.
Furthermore the size of studyNum is now also incremented by 1, as it stores information of both dimensions.
studyNum is now build up as follows:
The first entry is (still) storing an integer value giving information of the completeness of the study.
The second and third entry store the current run in the first and second dimension respectively.
\snippet Drivers/MercurySimpleDemos/ParameterStudy2DDemo.cpp PAR_SIM2D:privMem

Step 2: Set- and Get-functions for private member variables. \n
The set- and get-functions are extended to incorporate the second dimension with respect to ParameterStudy1DDemo.
\snippet Drivers/MercurySimpleDemos/ParameterStudy2DDemo.cpp PAR_SIM2D:setgetFunc

Step 3: Create the particle species. \n
Nothing changed with respect to ParameterStudy1DDemo

Step 4: Setup the initial conditions. \n
The only change with respect to ParameterStudy2DDemo is that now the second particle is dependent on the second dimension of the parameter study.
\snippet Drivers/MercurySimpleDemos/ParameterStudy2DDemo.cpp PAR_SIM2D:setupInit

Step 5: Setting up the parameter study. \n
Nothing changed with respect to ParameterStudy1DDemo, both actionsBeforeTimeLoop() and actionsAfterSolve() are the same.

Step 6: Creating the main function. \n
The only difference with ParameterStudy2DDemo is that now both study dimensions have to be set.
\code problem.setStudyDimensions(2,2) \endcode
This line results in 4 simulations being run, in which all 4 combinations of particle sizes are solved.
\snippet Drivers/MercurySimpleDemos/ParameterStudy2DDemo.cpp PAR_SIM2D:main

If you would like to look at the 1D or 3D parameter study demos:\n
\ref ParameterStudy1D "ParameterStudy1DDemo" \n
\ref ParameterStudy3D "ParameterStudy3DDemo" \n

Or return to \ref AdvancedOverview "Overview of advanced tutorials"

\page ParameterStudy3D Parameter study in 3D parameter space
#### Problem description
This tutorial is an extension to ParameterStudy2DDemo, and therefore has similar code structure. In ParameterStudy1DDemo and ParameterStudy2DDemo it has been
shown how to do 1D and 2D parameter studies. In those cases only the particle diameter has been changed, based on the simulation that is run. In this tutorial it is shown
how to perform a 3D parameter study on contact model properties, more specifically on studying the effect of stiffness, dissipation and density.
The parameter space now looks as follows:

\image html Tutorials/ParameterStudy/GridParamStudy3D.png Schematic overview of a 3D parameter study. Definitions of i, j ,k , dim1, dim2 and dim3 will be given later.

### Headers
The following headers are included: \n
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:headers
These are the headers needed for this tutorial.

## Before the main function
The main class inherits from Mercury3D.
\code ParameterStudy3DDemo : public Mercury3D \endcode
All steps needed in order to create this class are explained below.\n

Step 1: (Private) Member variables. \n
Similar to the extension of 1D to 2D parameter studies a new integer is introduced to store the size of the third dimension of the parameter study.
Furthermore the vector studyNum is again extended with 1, as it needs to store the information of the thrid dimension.
studyNum is now build up as follows:
The first entry is (still) storing an integer value giving information of the completeness of the parameter study.
The second, third and fourth entry store the current run in the first, second and thrid dimension respectively.
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:privMem

Step 2: Set- and Get-functions for private member variables. \n
The set- and get-functions are extended to incorporate the third dimension.
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:setgetFunc

Step 3: Create the particle species. \n
This tutorial was build around the wish to perform a 3D parameter study over the contact model properties.
Hence, compared to ParameterStudy1DDemo and ParameterStudy2DDemo, setting the particle species is now important.
The code however is still very similar, as createSpecies() had already been incorporated in the class.
For this reason we can simply use the same functions as before to get the simulation run numbers.
In this case it has been chosen to vary the stiffness, dissipation and density of the particles. However, if desired, all other particle properties could be changed by the run numbers.
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:createSpecies

Step 4: Setting up the initial conditions. \n
The onyl difference with respect to ParameterStudy1DDemo and ParameterStudy2DDemo is that now the particles do not vary in size anymore.
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:setupInit

Step 5: Setting up the parameter study. \n
Nothing changed with respect to ParameterStudy2DDemo, both actionsBeforeTimeLoop() and actionsAfterSolve() are the same.

Step 6: Creating the main function. \n
The only difference with ParameterStudy3DDemo is that now all three study dimensions have to be set.
\code problem.setStudyDimensions(2,2,3) \endcode
This line results in 12 simulations being run, in which all combinations of the contact model parameters are solved.
\snippet Drivers/MercurySimpleDemos/ParameterStudy3DDemo.cpp PAR_SIM3D:main

If you would like to look at the 1D or 2D parameter study demos:\n
\ref ParameterStudy1D "ParameterStudy1DDemo" \n
\ref ParameterStudy2D "ParameterStudy2DDemo" \n

Or return to \ref AdvancedOverview "Overview of advanced tutorials"


\page ProtectiveWall Parameter study using a protective wall

## Problem description

Particles are released from a specific height, roll through a slope and then a protective wall retains them. The user controls the number of particles inserted, the height of release, slope angle, grain size. The output data contain the .fstat file, which includes the information of numbers of grains contained by the wall and overflowing the wall, total force on the wall, volume fraction, stress inside the retained material. An illustrative description is presented in the figure below.

\image html Tutorials/ProtectiveWall/ProtectiveWall1.png Schematic representation of the parameter study including a protective wall, h: height of release, l: length, w: width, s: slope angle.

## Quick explanation:
There are two ways to run the tutorial. First, input parameters set directly in the main file:
ProtectiveWall.cpp. Second, input parameters are read from the command line after the compilation, for instance: ./protectiveWall -Np 500 -r 0.01 -h 0.1 -w 0.25 -l 1.0 -s 15.0 -t 20.0, where -Np: Number of particles, -r: particle radius.

## Some initial setups:
\image html Tutorials/ProtectiveWall/ProtectiveWall2.png Three different examples changing the initial setup.

## Simulation:
\image html Tutorials/ProtectiveWall/ProtectiveWall3.png Particles are released from a specific height, roll through a slope, and they are retained by a protective wall.

### Headers
The following headers are included: \n
\snippet Drivers/Tutorials/Advanced/ProtectiveWall.cpp AT_PW:headers
These are the headers needed for this tutorial. Further explanation can be found in \ref BeginnerTutorials.

### Main class:
The main class contains the constructor and member functions.
\snippet Drivers/Tutorials/Advanced/ProtectiveWall.cpp AT_PW:MainClass

### Main function
\snippet Drivers/Tutorials/Advanced/ProtectiveWall.cpp AT_PW:Mainfunction


\page openmpDemo Parallel processing using OpenMP

### Speeding up simulations by parallel execution on Symmetric Multiprocessors (SMPs) 

On both symmetric multiprocessors (SMPs) and massively parallel processors (MPPs), MercuryDPM can run simulations in parallel.
The distinction between the computer architectures is that SMPs (single-processor machines) use shared memory, while MPPs (clusters) use distributed memory.
We parallelise on shared memory with an OpenMP implementation and parallelize on distributed memory with an MPI implementation.
The following tutorials will demonstrate how to use OpenMP parallelisation in your code. 

To use the MercuryDPM-OpenMP framework, you need to include some code fragments in the main function, and some extra options during compiling and linking.

To illustrate this, let us consider a "Demo" application that we want to run in parallel using an activated OpenMP environment. The driver code is structured as follows:

\code
#include "Mercury3D.h"

class Demo : public Mercury3D {
  void setupInitialConditions() override {
    //define walls, boundary conditions, particle positions here
  }
};

int main() {
  Demo problem;
  //define contact law, time step, final time, domain size here
  problem.solve();
}
\endcode


Firstly, the OpenMP parallel environment has to be activated using \c cmake, i.e., by turning the flag \c Mercury_USE_OpenMP to \c ON as follows:
\code
# enter your build directory
cd MercuryBuild
# use cmake to change the CMake configuration
cmake . -DMercury_USE_OpenMP=ON
# Run fullTest with OpenMP activated
make fullTest
\endcode
Alternatively, you can use ccmake or cmake-gui to change the CMake configuration. Instructions for ccmake:
\code
# use ccmake or cmake-gui to change the CMake configuration
ccmake ../MercurySource
# Press [c] to configure
# Set Mercury_USE_OpenMP --> ON
# Press [c] twice to configure 2 times, then press [g] to generate
\endcode

Next, we set the number of threads to run in parallel for the program by calling the \c setNumberOfOMPThreads(n) function in the main function of the application, where \c n denotes the number of threads.

\code

...

int main() {
  Demo problem;
  ...
  //Set the number of threads (cores) for the identity-based OpenMP framework   
  problem.setNumberOfOMPThreads(4);
  problem.solve();
}
\endcode


After adding the above modifications, the simulation will be executed in parallel, with only one additional line included to the main() function.

Alternatively, you can set the number of OMP threads  using a command-line argument that is passed through helpers::readFromCommandLine(...) function:
\code

...

int main() {
  Demo problem;
  ...
  // command line arguments:
  problem.setNumberOfOMPThreads(helpers::readFromCommandLine(argc, argv, "-omp",1));
  problem.solve();
}
\endcode

In that case, the number of threads is set at execution-time via the command line, as follows:

\code
time ./Demo -test -omp 4  
\endcode

For an example of an OpenMP-ready code, see /Drivers/MercurySimpleDemos/FreeCooling2DinWallsDemo.cpp.
\image html Tutorials/Parallelisation/Tutorial10FCM2DWalls.png " " width=1600px


#### Performance

The table below shows performance results of the MercuryDPM-OpenMP framework:
\image html Tutorials/Parallelisation/Tutorial10FCM2DWallsOMPRuntime.png "Runtime and scalability of the MercuryDPM-OpenMP framework on a quad-core processor with up to 8 CPUs when hyperthreading" width=600px

The performance was tested using 200,000-particle simulation of a cooling granular gas on a quad core processor, with a time step 5 x 10-5 and a save count = 100, simulated up to a maximum time = 0.1. The fully functional parallel program produced exactly the same (identical) output as the serial application. We see that the execution time decreases with the number of threads. The theoretical maximum speedup is based on Ahmdahl's law for 4 cores, assuming that 68% of the code can be parallelised.



On the following pages, you'll find more parallelisation demonstrations:\n
\ref mpiDemo "Parallel processing using MPI" \n
\ref parallelInputOutputDemo "Parallel processing for Input-Output, I/O files" \n

Alternatively, go back to \ref AdvancedOverview "Overview of advanced tutorials"

\page mpiDemo Parallel processing using MPI

### Speeding up simulations by parallel execution on Massively Parallel Processors (MPPs)

On both symmetric multiprocessors (SMPs) and massively parallel processors (MPPs), MercuryDPM can run simulations in parallel.
The distinction between the computer architectures is that SMPs (single-processor machines) use shared memory, while MPPs (clusters) use distributed memory.
We parallelise on shared memory with an OpenMP implementation and parallelize on distributed memory with an MPI implementation.
The following tutorials will demonstrate how to use MPI parallelisation in your code. 


Before we get into the implementation, it's important to note that the MercuryDPM-MPI algorithm employs a simple domain decomposition technique. The decomposition splits the domain into \f$n_x \times n_y \times n_z\f$ subdomains and running each subdomain on a separate processor.

In the figure below, we show an actual hourglass filled with sand, and a corresponding sketch of a (two-dimensional) hourglass simulation, depicting a spatial decomposition using a Cartesian grid of \f$3 \times 1 \times 3\f$, using a total of 9 threads. The decomposition splits the domain (defined via \a setMin and #setMax in MercuryDPM) into intervals of equal size in each Cartesian direction. It is worth noting that the subdomains on the boundary of the domain extend towards infinity, thus even particles outside the domain belong to one of the subdomains. MPI is a distributed memory-approach, meaning all particles located inside a domain are only known to the thread simulating that particular subdomain. Note, we only distribute the particles, not the walls and boundaries, since they consume considerably less storage than the particles. For more information, see \cite Marnix2019.

\image html Tutorials/Parallelisation/Tutorial10ActualAndSimulatedSystem.png " " width=4000px

To run simulations in parallel, you need to define all particles in setupInitialConditions and you need to define the domain size in main(). Assume your driver code is structured as follows:

\code
#include "Mercury3D.h"

class Demo : public Mercury3D {
  void setupInitialConditions() override {
    //define walls, boundary conditions, particle positions here
  }
};

int main() {
  Demo problem;
  //define contact law, time step, final time, domain size here
  problem.solve();
}
\endcode


To run your simulation in parallel, you need to compile the code with MPI. Use cmake and turn the flag Mercury_USE_MPI to ON. You can do this either by loading cmake-gui and changing the use USE_MPI flag to ON; or, alternatively you do it on the command line:

\code
cd MercuryBuild
cmake . -DMercury_USE_MPI=ON
\endcode

You also need to tell your program about the decomposition it should use. To split your domain  setNumberOfDomains into \f$n_x \times n_y \times n_z\f$, add the following command in your main function before solve():

\code
//Set the number of domains for parallel decomposition
problem.setNumberOfDomains(Vec3D(nx,ny,nz));
\endcode

Now compile your code, and run it with \a mpirun. Make sure you use the correct number of processors (\f$n=n_x \cdot n_y \cdot n_z\f$) needed for the domain decomposition:

\code
//Set the number of domains for parallel decomposition
mpirun -np n MyDriverCode
\endcode

For an example of an MPI-ready code, see /Drivers/MercurySimpleDemos/HourGlass2DDemoMPI.cpp and Drivers/ParallelDrum/testDrum.cpp.
\image html Tutorials/Parallelisation/ParallelRotatingDrum.png


#### Performance

The performance of the MPI parallel algorithm has been tested for the case of a rotating drum of varying width; a snapshot of the simulations is shown in the above Figure. The serial algorithm shows
a near-linear scaling of computing time with the number of particles (Figure (a) shown below). Weak scaling of the parallel implementation is shown by measuring the efficiency E = Ts/(Tp*Nc), the ratio of
computing time for the serial and parallel implementation, for a varying number of cores Nc, keeping the number of particles per core constant. On a single node, efficiency decreases slowly 
with the number of cores, but levels off at around 40% for simulations that use hyperthreading (Figure (b) shown below). On multiple nodes, hyper-threading can be avoided, and the efficiency remains above 60% 
(Figure (c) shown below). Thus, the algorithm performs efficiently for large simulations, if the computational load per core is homogeneous.

\image html Tutorials/Parallelisation/MdpmMPIScalability.png


On the following pages, you'll find more parallelisation demonstrations:\n
\ref openmpDemo "Parallel processing using OpenMP" \n
\ref parallelInputOutputDemo "Parallel processing for Input-Output, I/O files" \n

Alternatively, go back to \ref AdvancedOverview "Overview of advanced tutorials"


\page parallelInputOutputDemo Parallel processing for Input-Output, I/O files

### Parallel File Systems (PFSs) for the MercuryDPM-MPI parallel-processing framework

#### a) One File-Per-Process, FPP I/O model

By default, MercuryDPM applications running in serial produce four main output files, in ASCII format. Each of the files carries the name of the code, followed by an
extension, .restart, .data, .fstat and .ene. By including the command "problem.setFileType(FileType::ONE_FILE)" in the main method below, we explicitly tell the DPM solver to write these default files:


\code
#include "Mercury3D.h"

class Demo : public Mercury3D {
  void setupInitialConditions() override {
    //define walls, boundary conditions, particle positions here
  }
};

int main() {
  Demo problem;
  //define contact law, time step, final time, domain size here
  
  //call setup for the one file-per-process output model
  problem.setFileType(FileType::ONE_FILE);

  problem.solve();
}
\endcode

 
Once the previously shown \ref mpiDemo "spatial decomposition" commands are included in the driver program, and the application is run in parallel using MPI, each process will write its own separate set of output files (.restart.n, .data.n, .fstat.n and .ene.n, \a n being the processor id). This is the so-called one file-per-process I/O model.
In the figure below, we plot the .data.n output files for the abovementioned hourglass simulation simulated using MPI on 4 cores. We see separated parts of the entire hourglass simulation, since the .data.n files are written individually. This method requires no message-passing communications, and as a result it's quick. However, it can result into a large number of output files as the number of process/CPUs increases, that might be hard to manage and process.

\image html Tutorials/Parallelisation/FFPModel.png

#### b) Shared Files, SF I/O model
Due to the above noted issues associated with the one file-per-process model, it can be desirable to output the data to a common file, written by all processes while running the parallelised code. To do this, we set the file type to either MPI_SHARED_FILE_ASCII
or MPI_SHARED_FILE_BINARY, for ASCII and binary formats respectively:

\code
#include "Mercury3D.h"

class Demo : public Mercury3D {
  void setupInitialConditions() override {
    //define walls, boundary conditions, particle positions here
  }
};

int main() {
  Demo problem;
  //define contact law, time step, final time, domain size here
  
  //shared-file output: comment or uncomment for processing either ASCII or Binary output
  problem.setFileType(FileType::MPI_SHARED_FILE_ASCII);
  //problem.setFileType(FileType::MPI_SHARED_FILE_BINARY);

  problem.solve();
}
\endcode

For the shared-file model, all processes open a common file and read or write different parts of the same file simultaneously.
As demostrated in the Figure below, the shared-file approach maintains a single output file.

\image html Tutorials/Parallelisation/SampleDATAFileMPIIO.png "HourGlass2DDemoMPI.data file, and the corresponding xballs output, for the 2D hourglass simulation, resulting from a 2-by-1-by-2 domain decomposition. Due to the fixed domain decomposition, a majority of the data is processed and written by only two of the four processes."

The figure below visualizes the content of the .data.n files obtained from writing one-file-per-process (subplots a and b), and the content of the .data file obtained from writing a shared file (subplot c).

\image html Tutorials/Parallelisation/InterpretedMPIIO.png

### The MPI-IO Shared Restart Demo (MPI processes reading from a Common-File)

Generally, in order to restart a simulation in MercuryDPM, we replace the simple solve command in the main function by solve(argc, argv), for reading in command-line arguments.
Running the code with the command-line argument "-r" forces a restart; "-t [time]" can be used to reset the final time. When the MPI shared I/O model is enabled, the pallelised code is executed with the "mpirun" command as illustrated below:

\code
#include "Mercury3D.h"

class Demo : public Mercury3D {
  void setupInitialConditions() override {
    //define walls, boundary conditions, particle positions here
  }
};

//first run Demo using "./Demo"
//then restart Demo using e.g. "mpirun -np 4 ./Demo -r -tmax 0.2"
int main() {
  Demo problem;
  //define contact law, time step, final time, domain size here
  
  //shared-file output: comment or uncomment for processing either ASCII or Binary output
  problem.setFileType(FileType::MPI_SHARED_FILE_ASCII);
  //problem.setFileType(FileType::MPI_SHARED_FILE_BINARY);

  problem.solve(argc,argv);
}
\endcode

When restarting the application, all  processes in a parallel job will  read  the entire contents of the common, single restart file.
For now, the parallel data readers are not smart enough to read-in only the portion of the data that they need. However, the collection of "actual data or information" that all
processes require is accessible and simulations restart smoothly. Below are snapshot visualisations demonstrating the MPI-IO shared restart/read in action.

\image html Tutorials/Parallelisation/RestartDemoMPIIO.png "Several restart-cases through the command: mpirun -np 4 ./# -r -tmax τ, for different values of the maximum simulation time, τ in seconds. The # symbolises the simulation label/name (\c HourGlass2DDemoMPI)."


### Performance evaluation for the parallel file systems:

Finally, some performance results for comparing the above parallel I/O models are provided in the table below:
 
\image html Tutorials/Parallelisation/mpiioPerformance.png "Runtime for the one file-per-process (FPP) and collective (shared) I/O for the MercuryDPM-MPI code, when writing ASCII formatted-files for the Hour Glass 2D test application with 900 particles." width=600px




On the following pages, you'll find more parallelisation demonstrations:\n
\ref openmpDemo "Parallel processing using OpenMP" \n
\ref mpiDemo "Parallel processing using MPI" \n

Alternatively, go back to \ref AdvancedOverview "Overview of advanced tutorials"

*/
