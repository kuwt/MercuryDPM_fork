
/*! \page Tutorials Fun with MercuryDPM (Tutorials)

The idea behind these tutorials, listed below, is to help the user improve his/her rapport with coding and problem solving in MercuryDPM. Most of the tutorials are designed to solve a simple problem. Each tutorial illustrates a new feature of MercuryDPM and gradually builds up on its level of difficulty.\n
\n
- \subpage BeginnerTutorials
- \subpage AdvancedTutorials

You can find a list of all tutorials \subpage Tcodes "here".

In case of any typos or suggestions for new tutorials, please do not hesitate to contact the MercuryDPM team.
*/

/*! \page BeginnerTutorials Beginner tutorials
This page contains the following tutorials: \n

- \ref T1
- \ref T2
- \ref T3
- \ref T4
- \ref T5
- \ref T6
- \ref T7
- \ref T8
- \ref T9

\section T1 T1: Particle motion in outer space
\image html Tutorials/T1/Tutorial1.jpg Particle moving with a constant velocity in outer space.

#### Problem description:
The first tutorial is setup to simulate a particle moving with a constant velocity in the absence of gravity. You can find the simulation setup in \b Tutorial1.cpp
The detailed description of this tutorial is presented below.\n

###Headers:
The headers are necessary to set up the simulations. They come from the kernel and standard libraries (see \ref DevelopersGuideKernel). Headers files usually have a <EM> .h </EM> or <EM> .hpp </EM> extensions. For example:
\snippet Drivers/Tutorials/Tutorial1.cpp T1:headers

###Before main function:

A class is the guide for objects to connect with handlers. \n

You can find in the code:

\code class Tutorial1 : public Mercury3D \endcode

Here is defined the class Tutorial1, which is inherited from the main class  \ref Mercury3D. Then, you can call the function to fit the initial conditions of the problem:

\code void setupInitialConditions()\endcode

It creates the problems’ initial conditions to define the radius, position, velocity of particles. In order to create a particle, the following structure must be used:

\snippet Drivers/Tutorials/Tutorial1.cpp T1:createParticle

The particle data members as positions, radius and velocities are pointed by using an object (P0) to their class member. For the case of the mentioned data members, the class member is called \ref BaseParticle. Then, the defined information is sent to its corresponding handler: \b  particleHandler by using the function \ref copyAndAddObject

###Main function:
In the main function, the global parameters of the problem are defined. It includes gravity, spatial dimensions (x,y,z), total run time, the type of contact law, etc. \n
The object 'problem' is an instance of the defined class \ref Tutorial1. Global parameters and species will point to the object 'problem'.

\code
Tutorial1 problem;
\endcode

Then, the data members are defined as:

\snippet Drivers/Tutorials/Tutorial1.cpp T1:problemSetup

Subsequently, the \ref species of the problem are defined. It means, the properties (density,stiffness) and the corresponding contact law (for this tutorial, see \ref LinearViscoelasticSpecies).
Initially, when a particle is created, it attains the properties of a default species type with ‘0’ as its index.

\snippet Drivers/Tutorials/Tutorial1.cpp T1:speciesProp

Here, 'species' is an object of the class: \ref LinearViscoelasticSpecies. Data members are fitted to point to this object, and then, coppied and added to their corresponding handler \ref speciesHandler.

Outputs:\n

Data output is vital to analyse simulations, which leads to defining ways to save the simulation data for post processing.\n
The simulations generate several types of data files.

\snippet Drivers/Tutorials/Tutorial1.cpp T1:output

Thereby, data members and member functions are pointed to the object 'problem'.\n

For XBalls users, additional display options can be set as below

\snippet Drivers/Tutorials/Tutorial1.cpp T1:visualOutput

After all the simulation parameters are set, we reach a point where we put all the above bits of code in action by the following statements

\snippet Drivers/Tutorials/Tutorial1.cpp T1:solve

\n
\section T2 T2: Particle motion on earth
\image html Tutorials/T2/Tutorial2.jpg Particle falling due to gravity.

#### Problem description:
In \b Tutorial2.cpp, we simulate a particle when dropped under the influence of gravity, \f$ g = 9.81 m/s^2\f$. Basically, this tutorial is an extension of \b Tutorial1.cpp with few minor changes.\n
All we need to do is to change the initial particle position and velocity in the inherited class Tutorial2.\n

\snippet Drivers/Tutorials/Tutorial2.cpp T2:createParticle

Also, the gravity vector in the main function:

\snippet Drivers/Tutorials/Tutorial2.cpp T2:problemSetup

\n
\section T3 T3: Bouncing ball (elastic)
\image html Tutorials/T3/Tutorial3.jpg Particle bouncing off the blue wall.

#### Problem description:
The \b Tutorial3.cpp simulates a particle bouncing off a wall. It is assumed the collistion between the particle and the wall is elastic by implying that the restitution coefficient is unity. It means that the particle velocity before and after collision remains the same.
Additionally, we will learn how to add a wall over which the ball bounces.

### Headers:
The header \ref InfiniteWall.h is included.

\snippet Drivers/Tutorials/Tutorial3.cpp T3:headers


### Before the main class:
The class \ref InfiniteWall is included in the inherited class \ref Tutorial3:

\snippet Drivers/Tutorials/Tutorial3.cpp T3:class

Where the object "w0" is an instance of the class \b InfiniteWall. Then, the function "copyAndAddObject" coppy and add the object to its corresponding handler. The above set of statements, create and place the wall at \f$ Z_{min} \f$.\n

Note: Don’t forget to include the InfiniteWall.h header, as shown in the header section. In some sense, creation and addition of a wall is similar to creation and addition of a particle.

\n
\section T4 T4: Bouncing ball with dissipation (inelastic)
\image html Tutorials/T4/Tutorial4.jpg Particle bouncing off the blue wall with restitution coefficient.

#### Problem description:
In \b Tutorial4.cpp, the difference between an elastic and inelastic collision between a particle and a wall is illustrated. The only difference between \ref Tutorial3.cpp and \ref Tutorial4.cpp is the value of the restitution coefficient:
\code double rc = 0.88; // restitution coefficient \endcode
See \ref T4code for more details.

\n
\section T5 T5: Elastic collision (2 particles)
\image html Tutorials/T5/Tutorial5.jpg Particles moving towards each other.

Problem description:\n
So far, in the above tutorials, we have seen how a particle and a wall interact during a collision. In this tutorial, we illustrate how two particles interact using \b Tutorial5.cpp. For this purpose, we need two particles. The particles may or may not be of the same species type. But, here we shall assume they are of same species and same size.\n

### Before the main function
\snippet Drivers/Tutorials/Tutorial5.cpp T5:class
On comparison between the above class and class Tutorial1, we see how an additional particle is added. Two particles are created, and positioned oppositely apart at a certain distance between them. Both the particles, have a certain velocity directing them towards each other.

\n
\section T6 T6: Elastic collisions with periodic boundaries
\image html Tutorials/T6/Tutorial6.jpg (a) Illustrates the idea behind periodic boundaries, particle exiting boundary b2 re-enters through boundary b1 <br> (b) Illustrates the problem setup.

#### Problem description:
In order to have multiple collisions, \ref Tutorial5.cpp is fitted with periodic boundaries in X.

### Headers:
\snippet Drivers/Tutorials/Tutorial6.cpp T6:headers
The header \ref PeriodicBoundary.h is included.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial6.cpp T6:class
In the Class Tutorial6\n
(i) we create two particles of same type and different sizes. (ii) we setup periodic boundaries in X-direction as
\snippet Drivers/Tutorials/Tutorial6.cpp T6:periodicBoundary

Where "b0" is an instance of the class \ref  PeriodicBoundary. Then, the object is copied and added to its corresponding handler:  \ref boundaryHandler.

\n
\section T7 T7: Motion of a particle in a two dimensional (2D) box
\image html Tutorials/T7/Tutorial7.jpg Particle motion in a box (blue and black denote the walls).

#### Problem description:
In previous tutorials, we have seen how a particle interacts with a wall and itself. In this tutorial, we will design boxes of different shapes by using more than one wall. As an example, in absence of gravity, we will simulate a particle moving in a two dimensional square shaped box. We consider two dimensions only for the sake of simplicity.
The same idea was introduced in \ref Tutorial3.cpp.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial7.cpp T7:class
In this class, we setup a 2D square shaped box or a polygon by adding more walls as shown above. In total, we have 4 walls forming our box within which the particle will traverse.
Note: As we simulate in 2D, no walls are set in z-direction.

### Main function:
As our simulation is two dimensional, we set the system dimensions as 2
\code problem.setSystemDimensions(2);\endcode

The complete code for the above problem description can be found in \ref Tutorial7.cpp.

\n
\section T8 T8: Motion of a particle in a box with an obstacle
\image html Tutorials/T8/Tutorial8.jpg

#### Problem description:
We extend the problem setup of Tutorial 7, by adding a rectangular block as shown in the above figure. To create this block of wall or obstacle, we will use the Class \ref IntersectionOfWalls. Before we go ahead it is advised to know the difference between an infinite wall and finite wall, see \ref WallTypes. As an example, we create an obstacle using a set of finite walls and place it within the box created using a set of infinite walls. See the above figure.

### Headers:
\snippet Drivers/Tutorials/Tutorial8.cpp T8:headers

The header \ref IntersectionOfWalls.h is included.

### Before the main function:
\image html Tutorials/T8/Tutorial8b.jpg

To add intersection walls, we use:
\snippet Drivers/Tutorials/Tutorial8.cpp T8:finiteWall

where "w1" is an instance of the class \ref IntersectionOfWalls. This surface (wall) will have the properties of the index 0: "getObject(0)". Then, the object is coppied and added to its corresponding handler:  \ref wallHandler.

\n
\section T9 T9: Motion of a ball over an inclined plane (Sliding + Rolling)
\image html Tutorials/T9/Tutorial9.jpg

#### Problem description:
the motion of three particles over an inclined plane is presented in \ref Tutorial9.cpp. Here, the particles are fitted with different features.

### Headers:

\snippet Drivers/Tutorials/Tutorial9.cpp T9:headers

For \ref Tutorial9.cpp, the header which implements the elastic properties and contact force modelc has been changed. In order to include the rolling and sliding effects, \ref LinearViscoelasticFrictionSpecies.h is used.

### Before the main function:
\snippet Drivers/Tutorials/Tutorial9.cpp T9:class

Three particles are fitted with radius, initial positions and initial velocities.Then, all particles are coppied and added to their corresponding handler. \n
It is defined the object 'w0' as an instance of the class  InfiniteWall. For this tutorial, the surface will have the same properties of "object0". It means the surface and the first particle will have the same elastic properties.

### Main function:

\snippet Drivers/Tutorials/Tutorial9.cpp T9:main

The main function of \ref Tutorial9.cpp presents how the elastic features of particles are defined. Also, a new function is added to combine features of different indexes: getMixedObject.


\page Tcodes Codes for tutorials

\section T1code Particle motion in outer space (code)
Return to tutorial \ref T1
\includelineno Drivers/Tutorials/Tutorial1.cpp
Return to tutorial \ref T1

\section T2code Particle motion on earth (code)
Return to tutorial \ref T2
\includelineno Drivers/Tutorials/Tutorial2.cpp
Return to tutorial \ref T2

\section T3code Bouncing ball - elastic (code)
Return to tutorial \ref T3
\includelineno Drivers/Tutorials/Tutorial3.cpp
Return to tutorial \ref T3

\section T4code Bouncing ball - inelastic (code)
Return to tutorial \ref T4
\includelineno Drivers/Tutorials/Tutorial4.cpp
Return to tutorial \ref T4

\section T5code Elastic collision - 2 particles (code)
Return to tutorial \ref T5
\includelineno Drivers/Tutorials/Tutorial5.cpp
Return to tutorial \ref T5

\section T6code Elastic collisions with periodic boundaries (code)
Return to tutorial \ref T6
\includelineno Drivers/Tutorials/Tutorial6.cpp
Return to tutorial \ref T6

\section T7code Motion of a particle in a two dimensional box (code)
Return to tutorial \ref T7
\includelineno Drivers/Tutorials/Tutorial7.cpp
Return to tutorial \ref T7

\section T8code Motion of a particle in a box with an obstacle (code)
Return to tutorial \ref T8
\includelineno Drivers/Tutorials/Tutorial8.cpp
Return to tutorial \ref T8

\section T9code Motion of a ball over an inclined plane (code)
Return to tutorial \ref T9
\includelineno Drivers/Tutorials/Tutorial9.cpp
Return to tutorial \ref T9

\section CoilSelfTestCode Particles driven by a rotating coil (code)
Return to tutorial \ref CoilSelfTest
\dontinclude Drivers/SelfTests/Walls/CoilSelfTest.cpp
\skip #include
\until the end
Return to tutorial \ref CoilSelfTest

\section ChuteDemoCode Particles on an inclined chute (code)
Return to tutorial \ref ChuteDemo
\dontinclude Drivers/ChuteDemos/ChuteDemo.cpp
\skip #include
\until the end
Return to tutorial \ref ChuteDemo

\section RoughBottomDemoCode Particles on a chute with a multilayered bottom (code)
Return to tutorial \ref RoughBottomDemo
\dontinclude Drivers/ChuteDemos/roughBottomDemo.cpp
\skip #include
\until the end
Return to tutorial \ref RoughBottomDemo


\page WallTypes Different types of walls
Walls are crucial in most of our problem setups and hence we have a variety of walls to suit the needs of our users.
\section InfWall Infinite Wall
\image html Walls/infiniteWall.jpg Infinite wall
A standard wall is a plane defined  as {x: normal*x=position}, with normal being the outward unit normal vector of the wall. A particle touches a standard wall if position-normal*x<=radius. Given the normal, a wall can be placed at any given position.\n
The black strip denotes the inner side of the wall. The particles interact with the wall along the blue strip.
\section FinWall Finite Wall
\image html Walls/finiteWall.jpg A block of wall formed by set of infinite walls.
Finite wall is basically a set of infinite walls or A finite wall is convex polygon defined by a set of normals normal_i and positions position_i. For example, to create a polygonal obstacle (in 2D or 3D), we consider the a set of infinite walls and create the obstacle as an intersection of all the infinite walls. See above figure corresponding to finite walls.


*/

/*! \page AdvancedTutorials Advanced tutorials
\section AdvancedOverview Overview

The directories Drivers/MercurySimpleDemos and Drivers/ChuteDemos contain many demo codes that
illustrate the commonly used features of MercuryDPM:\n\n

\b MercurySimpleDemos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage CoilSelfTest <td> CoilSelfTest.cpp
    <td> #Coil
<tr><td>\subpage HourGlass2DDemo <td> HourGlass2DDemo.cpp
    <td> #IntersectionOfWalls
<tr><td>\subpage HourGlass3DDemo <td> HourGlass3DDemo.cpp
    <td> #AxisymmetricIntersectionOfWalls <br> #LinearViscoelasticFrictionSpecies
</table>


\b ChuteDemos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage ChuteDemo <td> ChuteDemo.cpp
    <td> #Chute
<tr><td>\subpage RoughBottomDemo <td> roughBottomSelfTest.cpp
    <td> #ChuteBottom
<tr><td>\subpage ChuteWithHopper <td> HopperSelfTest.cpp
    <td> #ChuteWithHopper
</table>


\b Coarse-Grain Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage FiveParticles <td> FiveParticles.cpp
    <td> #Coil
<tr><td>\subpage LeesEdwards <td> LeesEdwardsSelfTest.cpp
        <td> #LeesEdwardsBoundary
</table>

\b Sintering Demos:
<table>
<tr><th> Description <th>%File Name
    <th> Illustrated Features
<tr><td>\subpage SinteringDemos <td> SinterPair.cpp
    <td> #Sinter
</table>

\page CoilSelfTest Particles driven by a rotating coil

#### Problem description:
This tutorial simulates particle flows around a coil for a short time. The code can be found in \b CoilSelfTest.cpp. It treats particles placed in a feeder being driven forward by a rotating coil.

### Headers
The following headers are included:
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:headers
These are basically the headers used for the beginner tutorials, except for the additional Coil class.

### Before the main function

CoilSelfTest, like many of the previous tutorials, inherits from the Mercury3D class.
\code class CoilSelfTest : public Mercury3D \endcode
The different components of the class will be explained in turn in the following.

step 1: Define Walls\n
The particles are initially contained by a container made up of six walls, five of which are defined to be infinite. The wall in the positive Z-direction is different. Its normal is set (<tt>rightWall->set(...</tt>) in the positive Z-direction (<tt>Vec3D(0, 0, 1)</tt>), is set a distance \c zMax_ (which is returned by <tt>getZMax()</tt>) from the origin, and contains a 'hole' (which is practically a horizontal tube, since the wall is 'infinite') around the X-axis of radius \c 1.0 in order to let the particles through.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:walls

step 2: Coil\n
After that the Coil object is added. Its geometrical properties are subsequently set by using the Coil::set() method, specifying its starting position (the origin, i.e. <tt>Vec3D(0,0,0)</tt>), its length (<tt>1.0</tt>), its radius (<tt>1.0 - particleRadius</tt>), its number of turns (<tt>2.0</tt>), its rotation speed (<tt>-1.0</tt> revelations per second) and its thickness (<tt>0.5 * particleRadius</tt>). \n
NB: its direction or central axis is not specified, since these are the Z-direction and the Z-axis, respectively, by default.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:coil

step 3: Create Particles\n
The particle properties are set subsequently. The particleHandler is cleared just to be sure it is empty, then the particle to be copied into the container is created and the previously set species is assigned to it. The particle is assigned a zero velocity and the previously defined particle radius.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:particle

step 4: Place Particles\n
After specifying the particle properties, the container is filled with copies of the particle. In this example, particles are placed in a rectangular grid pattern, on evenly spaced positions. First, the number of particles that fit in each direction is computed. Then, a triple for-loop passes every possible particle position, and a particle is placed on the position if there's no part of the coil there.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:placeparticles

Data members:\n
CoilSelfTest only has two (public) data members, namely a pointer to the coil:
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:datamembers

Actions Before TimeStep:\n
The \b actionsBeforeTimeStep() method specifies all actions that need to be performed at the beginning of each time step, i.e. \a before the actual numerical solution at that time step is computed. In this case, it states that from 1 second into the simulation time and onward, the coil should turn with the given rotational speed.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:beforetime

### Main Function
In the main program, a CoilSelfTest object is created, after which some of its basic properties are set like its number of dimensions (three), time step and saving parameters. Lastly, the problem is actually solved by calling its \b solve() method.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:main

Next, the particle species is defined. The particles in this problem will use a linear visco-elastic (normal) contact model.
The dissipation and stiffness defining the contact model can be set in different ways. In this example the contact model properties are set by giving a collision time, coefficient of restitution and the particle mass.
\snippet Drivers/SelfTests/Walls/CoilSelfTest.cpp CST:species

### Reference:
<a href="https://www.sciencedirect.com/science/article/pii/S0032591016301206?via%3Dihub"> Imole, O. I., Krijgsman, D., Weinhart, T., Magnanimo, V., Montes, B. E. C., Ramaioli, M., & Luding, S. (2016). Reprint of" Experiments and discrete element simulation of the dosing of cohesive powders in a simplified geometry". Powder technology, 293, 69-81.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page HourGlass2DDemo Flow through a 2D hourglass/silo

<img src="HourGlass2DDemo.png" align="right">

#### Problem description:
A 3D hour glass/silo is simulated, i.e. a square domain with a neck in the middle (see snapshot on the right).
Particles are inserted into the upper half of the domain and flow into the lower half due to gravity.

Here a short paraview animation of the code's output.
\htmlonly
<br><iframe width="420" height="315" src="https://www.youtube.com/embed/IQSn1Yv47l4" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

This code illustrates the effect of friction in DPM simulations. If the friction is high enough, arching is observed at the neck, where particles interlock to obstruct the flow.
It also illustrates how to use IntersectionOfWalls to set up a convex polygonal wall, i.e. the neck.

### Defining an intersection of walls
The neck is defined by two IntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass2DDemo.cpp CST:neck


(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page HourGlass3DDemo  Flow through a 3D hourglass/silo

<img src="HourGlass3DDemo.png" align="right">

#### Problem description
A 3D hour glass/silo is simulated, i.e. a cylindrical domain with a neck in the middle (see snapshot on the right).
Particles are inserted into the upper half of the domain and flow into the lower half due to gravity.

Here a short paraview animation of the code's output.
\htmlonly
<br><iframe width="420" height="315" src="https://www.youtube.com/embed/2QxP2MT2TVo" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

This code illustrates the effect of friction in DPM simulations. If the friction is high enough, arching is observed at the neck, where particles interlock to obstruct the flow.
It also illustrates how to use AxisymmetricIntersectionOfWalls to set up axisymmetrical shapes, i.e. the outer cylinder and the neck.

### Defining an axisymmetric wall
The outer wall is defined by an AxisymmetricIntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass3DDemo.cpp CST:outer
The neck is also defined by an AxisymmetricIntersectionOfWalls object:
\snippet Drivers/MercurySimpleDemos/HourGlass3DDemo.cpp CST:neck

(Return to \ref AdvancedOverview "Overview of advanced tutorials")


\page ChuteDemo Particles on an inclined chute
#### Problem description
%File \b ChuteDemo.cpp treats particles cascading down an inclined chute. The entire code of this problem can be viewed here: \ref ChuteDemoCode.

\htmlonly
<video src="chutedemo_compressed.ogv" id="movie" controls height="240"> henk </video>
\endhtmlonly

### Headers
The following headers are included:
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:include
The particle species is manually set here, and therefore needs to be included. We're treating a chute problem here, and the Chute class needs to be included therefore as well. The particles, walls and boundaries classes are already implemented by the chute class and don't need inclusion here.

### <tt> int %main()</tt>
Since the whole structure of the problem is already implemented in the Chute class, no separate class needs to be set up. The setup of initial conditions of the Chute class is shortly treated at \ref ChuteSetupInitialConditions "the end of this section". \n

The main driver program starts by initialising a Chute object. Next, the most basic problem properties are set, namely its name (which determines the naming of the data output files), save count (which is the number of time steps skipped between every saved one), particle
collision time (which is a species property, but also used in setting the time step), time step and maximum time. Note, that the total number of time steps saved to the output files is not directly set, but is equal to the maximum time divided by time step size \a and save count.

\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:initial

\n
Next, the particle properties are set. \c setFixedParticleRadius() sets the radius of the fixed chute bottom particles, while \c setInflowParticleRadius() sets the inflow particles to be monidisperse with the given particle radius. If inflow particles with random radii are desired, \c setMinInflowParticleRadius() and \c setMaxInflowParticleRadius() can be used instead to set the minimum and maximum particle radius, respectively. \n
The particle species (i.e. its intrinsic material properties) are set next, by specifying the density (<tt>species.setDensity()</tt>) and
the characteristic collision time and coefficient of restitution (with a typical particle mass given; <tt>species.setCollisionTimeAndRestitutionCoefficient(\f$ t_c, r_c, m\f$)</tt>).

\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:particles

\n
The chute properties are subsequently set by specifying the chute's length, width and angle relative to the horizontal.
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:chute

\n
The chute inflow parameters (besides the previously set inflow particle properties) are set by specifying the inflow height (in Z-direction), the mean iflow particle velocity (in X-direction), and the particle velocity variance (in ratio of the mean velocity).
\snippet Drivers/ChuteDemos/ChuteDemo.cpp ChuteDemo:inflow

\n
After all the problem parameters are specified, the simulation is run by calling the \b solve() method.
\code problem.solve(); \endcode

### \anchor ChuteSetupInitialConditions Chute::setupInitialConditions()

\dontinclude Kernel/Chute.cc
\skip InitialConditions()
\until }

The setup of initial conditions of the Chute class starts by checking for the presence of a species, and returns an error if there is none. Make sure therefore that you assign a species to the Chute object's \b speciesHandler before you call the \b solve() method. \n
After that, the side walls (in the Y-direction) are set up by calling Chute::setSideWalls(). These are set to be solid, infinite walls by default, but can be set to be \a periodic instead by setting Chute::isChutePeriodic_ to be \b true. \n
A particle is then created (on the \a heap) which is assigned the first (and only) species in the speciesHandler which we earlier specified in the driver (\b ChuteDemo.cpp).\n
A ChuteInsertionBoundary is created, and its parameters subsequently set by its \b set() method. The set() method arguments are, respectively:
- \c p: the previously specified particle
- \c maxFailed_: internally used parameter
- <tt> Vec3D(getXMin(), getYMin(), getZMin())</tt>: the first defining corner of the cuboidal insertion boundary
- <tt> Vec3D(getXMax(), getYMax(), getZMax())</tt>: the second defining corner of the cuboidal insertion boundary
- \c min- / \c maxInflowParticleRadius_: the minimum and maximum radii of inflow particles
- \c fixedParticleRadius_: the particle radius making up the chute bottom
- \c inflowVelocity(Variance)_: the mean velocity of inflow particles and the allowed variance about the mean

After setting the insertion boundary characteristics, it is added to the problem's \b boundaryHandler. \n
Lastly, the chute's bottom is created. The \a type of bottom created may be set by calling the Chute::setRoughBottomType() method in the driver, giving either of the following four arguments (which are of type \c enum \c RoughBottomType):
- FLAT: just a flat wall (of the species given in the driver)
- MONOLAYER_ORDERED: (a single layer of) fixed particles in a rectangular grid pattern
- MONOLAYER_DISORDERED: (\b default) a single layer of randomly placed particles
- MULTILAYER: a few layers of randomly placed particles, with a random variation in vertical position as well

### Reference:
<a href="https://link.springer.com/article/10.1140%2Fepje%2Fi2012-12127-5"> Thornton, A. R., Weinhart, T., Luding, S., & Bokhove, O. (2012). Frictional dependence of shallow-granular flows from discrete particle simulations. The European Physical Journal E, 35(12), 127.</a>\n
<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0355-y">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). Closure relations for shallow granular flows from particle simulations. Granular matter, 14(4), 531-552.</a>


(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page RoughBottomDemo Particles on a chute with a multilayered bottom

#### Problem description:
%File \b roughBottomDemo.cpp treats particles cascading down an inclined chute with a rough bottom consisting of multiple layers of fixed particles. The entire code of this problem can be viewed here: \ref RoughBottomDemoCode.

### Headers
\snippet Drivers/ChuteDemos/roughBottomSelfTest.cpp RB:headers

### Before the main function
### Main function
\snippet Drivers/ChuteDemos/roughBottomSelfTest.cpp RB:main

### Reference:
<a href="https://link.springer.com/article/10.1140%2Fepje%2Fi2012-12127-5"> Thornton, A. R., Weinhart, T., Luding, S., & Bokhove, O. (2012). Frictional dependence of shallow-granular flows from discrete particle simulations. The European Physical Journal E, 35(12), 127.</a>\n
<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0355-y">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). Closure relations for shallow granular flows from particle simulations. Granular matter, 14(4), 531-552.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page ChuteWithHopper Chute with hopper

#### Problem description:

\ref Hopper3dDemo.cpp treats particles which flow from a hopper onto an inclined chute below. The entire code of this problem can be viewed here: \ref RoughBottomDemoCode.

### Headers
\snippet Drivers/ChuteDemos/HopperSelfTest.cpp CH:headers
### Before the main function
### Main function
\snippet Drivers/ChuteDemos/HopperSelfTest.cpp CH:main

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page FiveParticles Five Particles

#### Problem description:

This tutorial presents five particles positioned on a irregular base made from five fixed particles. The system is nondimensionalised such that particle diameter d = 1, particle mass m = 1 and gravity g = 1.
The code can be found in \ref FiveParticles.cpp.

\image html Tutorials/CG/FiveParticles.jpg Snapshot of the final state of the Five Particles simulation (left). Coarse-graining is applied to obtain the bulk density ρ (centre) and pressure p (right).

### Headers
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:headers

### Before the main function
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:class
### Main function
\snippet Drivers/Papers/BoundaryStatistics/FiveParticles.cpp FP:main

### Reference:

<a href="https://link.springer.com/article/10.1007%2Fs10035-012-0317-4">Weinhart, T., Thornton, A. R., Luding, S., & Bokhove, O. (2012). From discrete particles to continuum fields near a boundary. Granular Matter, 14(2), 289-294.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page LeesEdwards Lees Edward

#### Problem description:

Now we study a more complex situation, in which a continuum formulation makes sense: granular media sheared at a constant rate
The code can be found in \ref LeesEdwardsSelfTest.cpp.

\image html Tutorials/Shear/Lees.jpg Granular media sheared.

### Headers
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:headers

### Before the main function
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:class

### Main function
\snippet Drivers/SelfTests/Boundaries/LeesEdwardsSelfTest.cpp Lees:main

### Reference:
<a href="https://iopscience.iop.org/article/10.1088/0022-3719/5/15/006/meta">Lees, A. W., & Edwards, S. F. (1972). The computer study of transport processes under extreme conditions. Journal of Physics C: Solid State Physics, 5(15), 1921.</a>\n
<a href="https://ris.utwente.nl/ws/portalfiles/portal/20335358/granular.pdf">Granular Flow: From Dilute to Jammed States.</a>

(Return to \ref AdvancedOverview "Overview of advanced tutorials")

\page SinteringDemos Simple sintering process

#### Problem description:
This tutorial present a simple case of sintering between two particles. The code can be found in \ref SinterPair.cpp.

\image html Tutorials/Sintering/Sintering.jpg Sintering of two particles.

### Headers
\snippet Drivers/Sinter/SinterPair.cpp St:headers

### Before the main function
\snippet Drivers/Sinter/SinterPair.cpp St:class

### Main function
There are three different radii for this tutorial: 1.5e-6, 2.0e-6, 5.0e-7

\snippet Drivers/Sinter/SinterPair.cpp St:main

### Reference:
<a href="https://www.epj-conferences.org/articles/epjconf/abs/2017/09/epjconf162460/epjconf162460.html">Fuchs, R., Weinhart, T., Ye, M., Luding, S., Butt, H. J., & Kappl, M. (2017). Initial stage sintering of polymer particles–Experiments and modelling of size-, temperature-and time-dependent contacts. In EPJ Web of Conferences (Vol. 140, p. 13012). EDP Sciences.</a>


(Return to \ref AdvancedOverview "Overview of advanced tutorials")

*/