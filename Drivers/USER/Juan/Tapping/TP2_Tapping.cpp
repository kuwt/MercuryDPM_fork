//Copyright (c) 2013-2018, The MercuryDPM Developers Team. All rights reserved.
//For the list of developers, see <http://www.MercuryDPM.org/Team>.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name MercuryDPM nor the
//    names of its contributors may be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE MERCURYDPM DEVELOPERS TEAM BE LIABLE FOR ANY
//DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "Mercury3D.h"
#include "Species/ThermalSinterLinFrictionReversibleAdhesiveSpecies.h"
#include "Walls/InfiniteWall.h"
#include <Walls/AxisymmetricIntersectionOfWalls.h>
#include <Boundaries/CubeDeletionBoundary.h>

/* This code reads the information generated by LB_S1_insertion.
 * A plane is located at the top surface to compress the particles.
*/

// Main class:
class S2_Tapping : public Mercury3D{

private:
    InfiniteWall* lid;

    Mdouble meanCoordinationNumber = 0.0;
    Mdouble scalarNormalForce = 0.0;

    Mdouble newHeight = 0.0;
    unsigned NumberOfTaps;

    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpecies;

public:

    //Constructor
    S2_Tapping(unsigned NumberOfTaps_)
    {

        std::string readFilename = "TP1_PA12";

        setName(readFilename); //Name of the file to read.
        readRestartFile();

        setRestarted(false);

        NumberOfTaps = NumberOfTaps_;

        logger(INFO,"Name: %",getName());


        particleSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(0));
//
        Mdouble radius = particleHandler.getMeanRadius();

        double mass = particleSpecies->getMassFromRadius(radius);
        setTimeStep(0.02*particleSpecies->getCollisionTime(mass));

        // apply a certain tapping velocity, upwards-fraction, and period
        const double a = radius; //tapping amplitude
        const double tr = 200*50*getTimeStep(); //time to rise (and relax)
        const double tf = sqrt(2.0*a/9.8); //time to fall
        const double tp = tr+tf; //tapping period


        logger(INFO,"Tapping period % ms, rise fraction %, tapping amplitude % mm", tp*1000, tr/tp, a*1000);
        auto tapPosition = [a, tr, tp] (double time) {
            const Mdouble t = fmod(time,tp)/tr; // scaled time, rising from 0 to 1 while the plate rises
            const Mdouble tFall = (t-1)*tr;
            return Vec3D(0,0,t<=1 ? a*t : std::max(0.0, a-0.5*9.8*tFall*tFall));
        };

        setTimeMax(NumberOfTaps*tp);
        restartFile.setSaveCount(tp/getTimeStep());

        //Walls
        InfiniteWall base;
        base.setSpecies(speciesHandler.getObject(1));
        base.set({0,0,-1},{0,0,0});
        base.setPrescribedPosition(tapPosition);
        wallHandler.copyAndAddObject(base);

        setName("TP2_PA12");
        logger(INFO,"Name: %",getName());

    }

    // Write requested output to the ene file
    void writeEneTimeStep(std::ostream &os) const override
    {
        Mdouble MassParticlesInBed = particleHandler.getMass();
        Mdouble cylinderRadius = getXMax()/2.0;
//
        if (eneFile.getCounter() == 1)
        {
            os << "time com wall eneRatio volumeFraction\n";
        }
        double comZ = getCentreOfMass().Z;
        double wallZ = wallHandler.getObject(0)->getPosition().Z;
        double heightMin = particleHandler.getVolume()/(cylinderRadius*cylinderRadius*constants::pi);
        double volumeFraction = 0.5 * heightMin / (comZ-wallZ);
//
        double volumeInserted = volumeFraction*getTotalVolume();

        double massInserted = particleHandler.getMass();
//
        double densityInserted = massInserted/volumeInserted;
//
        os  << getTime() << ' ' //[1]
            << comZ << ' ' //[2]
            << wallZ << ' ' //[3]
            << getKineticEnergy()/getElasticEnergy() << ' '//[4]
            << volumeFraction << ' ' //[5]
            << volumeInserted << ' ' //[6]
            << getTotalVolume() << ' ' //[7]
            << massInserted << ' ' //[8]
            << densityInserted << ' ' //[9]
            << particleHandler.getNumberOfObjects() << '\n'; //[10]
    }


    //--------------------------------------------------
    // Also write the ene information to the screen
    void printTime() const override {
        Mdouble cylinderRadius = getXMax()/2.0;

        double comZ = getCentreOfMass().Z;
        double wallZ = wallHandler.getObject(0)->getPosition().Z;
        double heightMin = particleHandler.getVolume()/(cylinderRadius*cylinderRadius*constants::pi);
        double volumeFraction = 0.5 * heightMin / (comZ-wallZ);
        logger(INFO, "time % com % wall % ene % volFrac % %", getTime(), comZ, wallZ, getKineticEnergy()/getElasticEnergy(), volumeFraction, 0.5 * heightMin);
//        //writeEneTimeStep(std::cout);
    }
};

// Main Function:
int main(int argc UNUSED, char *argv[] UNUSED)
{

    //Set problem parameters:
    unsigned NumberOfTaps = 20;

    //Object:
    S2_Tapping oTest(NumberOfTaps);

    oTest.setXBallsAdditionalArguments("-solidf -v0");

    helpers::writeToFile(oTest.getName() + ".gnu",
                         "set xlabel 'Time [s]'\n"
                         "set ylabel 'COM_z [m]'\n"
                         "p [0.1:] '" + oTest.getName() + ".ene' u 1:2 w l t ''");

    oTest.setWallsWriteVTK(false);
    oTest.setParticlesWriteVTK(false);

    oTest.solve();

    return 0;
}