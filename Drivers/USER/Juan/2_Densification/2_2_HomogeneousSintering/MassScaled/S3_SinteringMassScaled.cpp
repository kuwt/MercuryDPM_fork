//Copyright (c) 2013-2023, The MercuryDPM Developers Team. All rights reserved.
//For the list of developers, see <http://www.MercuryDPM.org/Team>.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name MercuryDPM nor the
//    names of its contributors may be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE MERCURYDPM DEVELOPERS TEAM BE LIABLE FOR ANY
//DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "Mercury3D.h"
#include "Species/ThermalSinterLinFrictionReversibleAdhesiveSpecies.h"
#include "Walls/InfiniteWall.h"
//#include "CG/CG.h"

/* This code reads the information generated by S2_Compression file.
 * The temperature increases and heats up all particles. Thus, the Sintering process
 * occurs.
*/
// Main class:
class S3_Sintering : public Mercury3D{
public:
//
    //Constructor
    S3_Sintering()
    {
        setName("S2_CompressionScaledMass");
        readRestartFile();
        setRestarted(false);
        setName("S3_SinteringScaledMass");
        setParticlesWriteVTK(true);
        wallHandler.setWriteVTK(FileType::MULTIPLE_FILES);

        particleSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(0));
        wallSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(1));

        const Mdouble YoungM = 1.65e9; //[Pa] Young's Modulus for polyamide12

//        Mdouble K1 = 100.0* particleHandler.getMeanRadius();
        Mdouble K1 =  particleSpecies->getLoadingStiffness();
//        particleSpecies->setLoadingStiffness(K1);
//        particleSpecies->setUnloadingStiffnessMax(10*K1);
        particleSpecies->setCohesionStiffness(K1);

        particleSpecies->setComplianceZero(1.0/(2.0*YoungM)); //Book: Adhesive Particles
        particleSpecies->setSurfTension(0.041); //
        particleSpecies->setSinterAdhesion(0.001*K1);

        particleSpecies->setFluidity(4.1e-01);
        particleSpecies->setSeparationDis(2.7e-07);

        particleSpeciesAtMeltingPoint = new ThermalSinterLinFrictionReversibleAdhesiveSpecies(*particleSpecies);
    }
    //--------------------------------------------------
    //Destructure
    ~S3_Sintering() override
    {
        delete particleSpeciesAtMeltingPoint;
    }
    //--------------------------------------------------
    //Initial conditions
    void setupInitialConditions() override
    {
        particleSpeciesAtMeltingPoint->setLoadingStiffness(particleSpecies->getLoadingStiffness());
        double N = particleHandler.getNumberOfObjects();

        for (int i=0; i < N; i++) {
            particleHandler.getObject(i)->setSpecies(particleSpecies);
        }
    }
    //--------------------------------------------------
    Mdouble getTemperature()const
    {
        Mdouble heatingTemperature = startingTemp + gradientTemp*getTime();
        Mdouble coolingTemperature = maxTemp;

        if(getTime()>=timeCooling){
            coolingTemperature = startingTemp + gradientTemp*(getTimeMax() - getTime());
        }
        return std::min(std::min(heatingTemperature,coolingTemperature),maxTemp);
    }

    void setTemperature(Mdouble temperature)
    {
        static Mdouble oldTemperature = startingTemp;
//        TemBack = oldTemperature;
        Mdouble deltaTemperature = temperature-oldTemperature;
        Mdouble deltaCooling = temperature - meltTemp;

        Mdouble factorRadius = 1.0 - (deltaR * deltaTemperature);

        for (BaseParticle* p : particleHandler)
        {
            if (p->getSpecies()==particleSpecies)
            {
                p->setRadius((factorRadius * p->getRadius()));
            }
        }
        //change species properties
        Mdouble stiffnessFactor = 0.5*(1.0+tanh((meltTemp-temperature)/gradientTemp));
        Mdouble oldLoadingStiffness = particleSpecies->getLoadingStiffness();
        particleSpecies->setLoadingStiffness(stiffnessFactor*particleSpeciesAtMeltingPoint->getLoadingStiffness());

        //for decreasing temperature, change the maxOverlap
        if (deltaCooling<0.0)
        {
            for (BaseInteraction* cBase : interactionHandler)
            {
                auto c =  dynamic_cast<SinterLinInteraction*>(cBase);
                Mdouble unloadingStiffness = c->getUnloadingStiffness();
                c->setMaxOverlap(c->getMaxOverlap()
                                 *(unloadingStiffness-oldLoadingStiffness)
                                 /(unloadingStiffness-particleSpecies->getLoadingStiffness())
                );
            }
        }
        oldTemperature = temperature;
    }
    //--------------------------------------------------
    void actionsAfterTimeStep() override
    {
        setTemperature(getTemperature());
        newHeight = getSurfaceHeight();

        //To measure the mean coordination number.
        for (int i = particleHandler.getNumberOfObjects()-1; i>=0; i--)
        {
            meanCoordinationNumber += (particleHandler.getObject(i) -> getInteractions()).size();
        }
        meanCoordinationNumber /= particleHandler.getNumberOfObjects();
    }
    //--------------------------------------------------
    //Prints the temperature into the data file, such that you can plot it in paraview
    Mdouble getInfo(const BaseParticle& p) const override
    {
        auto tp = dynamic_cast<const ThermalParticle*>(&p);
        return tp->getTemperature();
    }
    //--------------------------------------------------
    Mdouble getSurfaceHeight() const
    {
        double height = 0;
        for (const BaseParticle* p : particleHandler)
        {
            double newHeight = p->getPosition().Z;
            if (height<newHeight) height = newHeight;
        }
        return height+particleHandler.getMeanRadius();
    }
    //--------------------------------------------------
    //Function to override the output file with specific parameters
    void writeFstatHeader(std::ostream &os) const override
    {
        Mdouble meanOverlap = interactionHandler.getMeanOverlap();
        Mdouble meanRadius = particleHandler.getMeanRadius();

        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));

        Mdouble densityParticle = particleSpecies->getDensity()/1e12;

        Mdouble massParticle = densityParticle*volParticle;
        Mdouble massTotalParticles = massParticle*particleHandler.getNumberOfObjects();
        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2/2,2.0))*newHeight;
        Mdouble bulkDensity = massTotalParticles/(volParticlesPlusVoidInSystem);
        Mdouble volumeFraction = particleHandler.getVolume()/volParticlesPlusVoidInSystem;

        os << getTime()
        << " " << getTemperature()
        << " " << particleSpecies->getDensity()
        << " " << particleSpecies->getLoadingStiffness()
        << " " << meanOverlap
        << " " << sqrt(meanOverlap/meanRadius)
        << " " << bulkDensity
        << " " << volumeFraction
        << " " << meanCoordinationNumber
        << std::endl;
    }

    void printTime() const override
    {
        Mdouble volSystem = constants::pi*(std::pow(getXMax()/2,2))*getSurfaceHeight();

        Mdouble volTotalParticles = particleHandler.getVolume();
        Mdouble meanOverlap = interactionHandler.getMeanOverlap();
        Mdouble meanRadius = particleHandler.getMeanRadius();
//        Mdouble volParticlesInSystem = constants::pi*(getXMax())*newHeight;
        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));

        Mdouble densityParticle = particleSpecies->getDensity()/1e12;

        Mdouble massParticle = densityParticle*volParticle;
        Mdouble massTotalParticles = massParticle*particleHandler.getNumberOfObjects();
        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2/2,2.0))*getSurfaceHeight();
        Mdouble bulkDensity = massTotalParticles/(volParticlesPlusVoidInSystem);
        Mdouble TheoDensity = 450.0;
//        Mdouble RealDensity = massTotalParticles/volTotalParticles;

        Mdouble relativeDensity = bulkDensity/TheoDensity;

        std::cout << "t=" << std::setprecision(3) << std::left<< getTime()
                  << " Temp= " << std::setw(3) << getTemperature()
                  << " loading stiffness= " << std::setw(3) << particleSpecies->getLoadingStiffness()
                  << " pR= " << std::setw(3) << particleHandler.getMeanRadius()
                  << " MeanOverlap= "<< std::setw(3) << sqrt(meanOverlap/meanRadius)
                  << " MAxPosi= "<< std::setw(3) << getSurfaceHeight()
                  << " volumeFractionSys= "<< std::setw(3) << volTotalParticles/volSystem
                  << " meanCoordinationN.= "<< std::setw(3) <<meanCoordinationNumber
                  << " Bulk Density= "<< std::setw(3) << bulkDensity
//                  << " DensificationRate= "<< std::setw(3) << bulkDensity/RealDensity

                  << std::endl;

        static unsigned int counter = 0;
        if(++counter>100 && volTotalParticles/volSystem>=1.0){
            exit(-1);
        }
    }

private:
    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpecies;
    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpeciesAtMeltingPoint;
    ThermalSinterLinFrictionReversibleAdhesiveSpecies* wallSpecies;

    Mdouble deltaR = 1.0e-5; //[check] Thermal expansion coefficient

    Mdouble meanCoordinationNumber = 0.0;
    Mdouble newHeight = 0.0;

    Mdouble gradientTemp = 0.05; //[C/s]
    Mdouble timeCooling = 30; //[s]

    const Mdouble startingTemp = 170.0; //[C]
    const Mdouble meltTemp = 176.0; //[C]
    const Mdouble maxTemp = 180.0;

};

// Main function:
int main(int argc UNUSED, char *argv[] UNUSED)
{
    S3_Sintering s;
    s.setTimeStep(0.0008);
    s.setTimeMax(200);
    s.removeOldFiles();

    //--------------------------------------------------
    //This is for Coarse-Graining live.
    //Live CG to get results over time. For instance, plot stress vs time.
    //    //define coarse-graining resolved in z
    //    CG<CGCoordinates::Z> cgZ; //declare a cg object
    //    cgZ.setN(20);  //set number of mesh points in each spatial direction
    //    cgZ.setWidth(0.5); //set cg width
    //    s.cgHandler.copyAndAddObject(cgZ); // add the CG object to the cgHandler

    s.solve();

    //Coarse-Graining:
    //--------------------------------------------------
    // It creates the coarse-graining output file at the last iteraction.
    logger(INFO,"Execute 'source S3_SinteringScaledMass.sh' to get coarse-grained statistics at specific time step");
    helpers::writeToFile("S3_SinteringScaledMass.sh","../../../../../MercuryCG/fstatistics S3_SinteringScaledMass -stattype XZ -w 1.0e-5 -h 0.1e-5 -tmin 1.0 -tmax 1.1 -o S3_SinteringScaledMass.XZ.stat");

    //--------------------------------------------------
    // It creates the matlab visualization.
    logger(INFO,"Run 'S3_SinteringScaledMass.m' in MATLAB/octave to visualise the statistical output");
    helpers::writeToFile("DensificationRateS2.m","clc;clear all;close all\n"
                                                 "addpath('../../../../../MercuryCG/')\n"
                                                 "data = loadStatistics('S3_SinteringScaledMass.XZ.stat');\n"
                                                 "colormap(1-gray)\n"
                                                 "contourf(data.x,data.z,data.Density,20,'EdgeColor','none')\n"
                                                 "c = colorbar\n"
                                                 "c.Label.String = '\\rho';\n"
                                                 "title('Density')\n"
                                                 "xlabel('x')\n"
                                                 "ylabel('z');\n"
                                                 "axis equal\n"
                                                 "%%\n"
                                                 "addpath('/home/juan/Softwares/MercuryDPM_Branch/Trunk/Matlab');\n"
                                                 "particles=read_data('S3_SinteringScaledMass.data');\n"
                                                 "Cell = particles{637}(1,1); %Specific particle position at 1.119, which is in the cell 24\n"
                                                 "NumPart= Cell.N;\n"
                                                 "Pradius = Cell.Radius;\n"
                                                 "Position = Cell.Position;\n"
                                                 "a=linspace(0,2*pi,40);\n"
                                                 "xCircle = sin(a);\n"
                                                 "zCircle = cos(a);\n"
                                                 "hold on;\n"
                                                 "for i=1:length(Pradius)\n"
                                                 "  plot(Position(i,1) + Pradius(i)*xCircle,Position(i,3)+Pradius(i)*zCircle,'Color',.8*[1 1 1])\n"
                                                 "end\n"
                                                 "hold off");
    return 0;

    //--------------------------------------------------
    //An example of how to plot the results using gnuplot
    //Gnuplot:
    //set format xy "%.1f"
    //plot 'DensificationRateS2.fstat' using 1:2 title "Heating profile",
    //set ylabel "Temperature"
    //set xlabel "t [s]"
    //set ylabel "{/Symbol r} _{relative}"
}