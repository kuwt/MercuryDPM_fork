//Copyright (c) 2013-2018, The MercuryDPM Developers Team. All rights reserved.
//For the list of developers, see <http://www.MercuryDPM.org/Team>.
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name MercuryDPM nor the
//    names of its contributors may be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE MERCURYDPM DEVELOPERS TEAM BE LIABLE FOR ANY
//DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "Mercury3D.h"
#include "Species/ThermalSinterLinFrictionReversibleAdhesiveSpecies.h"
#include "Walls/InfiniteWall.h"
//#include "CG/CG.h"

/* This code reads the information generated by S2_Compression file.
 * The temperature increases and heats up all particles. Thus, the Sintering process
 * occurs.
*/
// Main class:
class S3_Sintering : public Mercury3D{

private:
    Mdouble T0_ = 0.0;
    Mdouble maxTemp_ = 0.0;
    Mdouble gradientTemp_ = 0.0; //[C/s] Heating rate
    Mdouble timeCooling = 0.18;
    Mdouble meltingTemperature_ = 0.0;

    Mdouble meanCoordinationNumber = 0.0;
    Mdouble deltaR_ = 0.0; //[check] Thermal expansion coefficient

    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpecies;
    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpeciesAtMeltingPoint;
    ThermalSinterLinFrictionReversibleAdhesiveSpecies* wallSpecies;
public:
//
    //Constructor
    S3_Sintering(Mdouble deltaR, Mdouble startingTemperature, Mdouble  maxTemp, Mdouble gradientTemp,
                 Mdouble meltingTemperature, Mdouble setDeltaC, Mdouble setC1)
    {
        deltaR_ = deltaR;

        maxTemp_ = maxTemp;
        T0_ = startingTemperature;
        gradientTemp_ = gradientTemp;
        meltingTemperature_ = meltingTemperature;

        setName("S2_Compression_PA12_200L");
        readRestartFile();
        setRestarted(false);
        setName("S3_Sintering_PA12_200L");
//        setParticlesWriteVTK(true);
//        setWallsWriteVTK(FileType::MULTIPLE_FILES);
        wallHandler.removeLastObject();

        particleSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(0));
        wallSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(1));

        const Mdouble YoungM = 1.65e9; //[Pa] Young's Modulus for polyamide12

        Mdouble K1 =  particleSpecies->getLoadingStiffness();

//        particleSpecies->setCohesionStiffness(K1);
        particleSpecies->setSinterType(SINTER_APPROACH::VISCOELASTIC_CONTACT);  //FRENKEL OR VISCOELASTIC_CONTACT
        particleSpecies->setPenetrationDepthMax(1.45);
        particleSpecies->setComplianceZero(1.0/(2.0*YoungM)); //Book: Adhesive Particles
        particleSpecies->setSurfTension(0.041); //

        //To control:
        particleSpecies->setSinterAdhesion(0.01*K1);

        particleSpecies->setFluidity(setC1);
        particleSpecies->setSeparationDis(setDeltaC);

        particleSpeciesAtMeltingPoint = new ThermalSinterLinFrictionReversibleAdhesiveSpecies(*particleSpecies);
    }
    //--------------------------------------------------
    //Destructure
    ~S3_Sintering() override
    {
        delete particleSpeciesAtMeltingPoint;
    }
    //--------------------------------------------------
    //Initial conditions
    void setupInitialConditions() override
    {
        particleSpeciesAtMeltingPoint->setLoadingStiffness(particleSpecies->getLoadingStiffness());
//        particleSpeciesAtMeltingPoint->setCohesionStiffness(particleSpecies->getCohesionStiffness());

        double N = particleHandler.getNumberOfObjects();

        for (int i=0; i < N; i++) {
            particleHandler.getObject(i)->setSpecies(particleSpecies);
        }
    }
    //--------------------------------------------------
    Mdouble getTemperature()const
    {
        Mdouble heatingTemperature = T0_ + gradientTemp_*getTime();
        Mdouble coolingTemperature = maxTemp_;

        if(getTime()>=timeCooling){
            coolingTemperature = T0_ + gradientTemp_*(getTimeMax() - getTime());
        }
        return std::min(std::min(heatingTemperature,coolingTemperature),maxTemp_);
    }

    void setTemperature(Mdouble temperature)
    {
        static Mdouble oldTemperature = T0_;
        Mdouble deltaTemperature = temperature-oldTemperature;
        Mdouble deltaCooling = temperature - meltingTemperature_;

        Mdouble factorRadius = 1.0 - (deltaR_ * deltaTemperature);

        for (BaseParticle* p : particleHandler)
        {
            if (p->getSpecies()==particleSpecies)
            {
                p->setRadius((factorRadius * p->getRadius()));
            }
        }
        //change species properties
        Mdouble stiffnessFactor = 0.5*(1.0+tanh((meltingTemperature_-temperature)/gradientTemp_));
        Mdouble oldLoadingStiffness = particleSpecies->getLoadingStiffness();
        particleSpecies->setLoadingStiffness(stiffnessFactor*particleSpeciesAtMeltingPoint->getLoadingStiffness());

        //for decreasing temperature, change the maxOverlap
        if (deltaCooling<0.0)
        {
            for (BaseInteraction* cBase : interactionHandler)
            {
                auto c =  dynamic_cast<SinterLinInteraction*>(cBase);
                Mdouble unloadingStiffness = c->getUnloadingStiffness();
                c->setMaxOverlap(c->getMaxOverlap()
                                 *(unloadingStiffness-oldLoadingStiffness)
                                 /(unloadingStiffness-particleSpecies->getLoadingStiffness())
                );
            }
        }
        oldTemperature = temperature;
    }
    //--------------------------------------------------
    void actionsAfterTimeStep() override
    {
        setTemperature(getTemperature());

        //To measure the mean coordination number.
        for (int i = particleHandler.getNumberOfObjects()-1; i>=0; i--)
        {
            meanCoordinationNumber += (particleHandler.getObject(i) -> getInteractions()).size();
        }
        meanCoordinationNumber /= particleHandler.getNumberOfObjects();
    }
    //--------------------------------------------------
    //Prints the temperature into the data file, such that you can plot it in paraview
    Mdouble getInfo(const BaseParticle& p) const override
    {
        auto tp = dynamic_cast<const ThermalParticle*>(&p);
        return tp->getTemperature();
    }
    //--------------------------------------------------
    Mdouble getSurfaceHeight() const
    {
        double height = 0;

        for (const BaseParticle* p : particleHandler)
        {
            double newHeight = p->getPosition().Z;
            if (height<newHeight) height = newHeight;
        }

        return height+particleHandler.getMeanRadius();
    }
    //--------------------------------------------------
    //Function to override the output file with specific parameters
    void writeFstatHeader(std::ostream &os) const override
    {
        Mdouble volSystem = constants::pi*(std::pow(getXMax()/2,2))*getSurfaceHeight();

        Mdouble volTotalParticles = particleHandler.getVolume();
        Mdouble meanOverlap = interactionHandler.getMeanOverlap();
        Mdouble meanRadius = particleHandler.getMeanRadius();
        Mdouble meanContactRadius = sqrt(meanOverlap/meanRadius)*meanRadius;
//        Mdouble volParticlesInSystem = constants::pi*(getXMax())*newHeight;
        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));

        Mdouble densityParticle = particleSpecies->getDensity();

        Mdouble massParticle = densityParticle*volParticle;
        Mdouble massTotalParticles = particleHandler.getMass();
        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2,2.0))*getSurfaceHeight();
        Mdouble bulkDensity = massTotalParticles/volParticlesPlusVoidInSystem;
        Mdouble TheoDensity = 550.0;

        os << getTime() //1
           << " " << getTemperature()//2
           << " " << particleSpecies->getDensity()//3
           << " " << particleSpecies->getLoadingStiffness()//4
           << " " << meanOverlap//5
           << " " << meanContactRadius //6
           << " " << sqrt(meanOverlap/meanRadius)//7
           << " " << std::setw(3) << wallHandler.getLastObject()->getPosition().Z//8
           << " " << getSurfaceHeight()//9
           << " " << (wallHandler.getLastObject()->getPosition().Z-getSurfaceHeight())/wallHandler.getLastObject()->getPosition().Z//10
           << " " << bulkDensity//11
           << " " << TheoDensity//12
           << " " << volTotalParticles/volSystem//13
           << " " << meanCoordinationNumber//14
           << " " << wallHandler.getObject(0)->getForce().Z//15
           << std::endl;


    }

    void printTime() const override
    {
        Mdouble volSystem = constants::pi*(std::pow(getXMax()/2,2))*getSurfaceHeight();

        Mdouble volTotalParticles = particleHandler.getVolume();
        Mdouble meanOverlap = interactionHandler.getMeanOverlap();

        Mdouble meanRadius = particleHandler.getMeanRadius();
//        Mdouble volParticlesInSystem = constants::pi*(getXMax())*newHeight;
        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));

        Mdouble densityParticle = particleSpecies->getDensity();

        Mdouble massParticle = densityParticle*volParticle;
        Mdouble massTotalParticles = particleHandler.getMass();
        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2,2.0))*getSurfaceHeight();
        Mdouble bulkDensity = massTotalParticles/volParticlesPlusVoidInSystem;
        Mdouble TheoDensity = 650.0;
//        Mdouble RealDensity = massTotalParticles/volTotalParticles;

        Mdouble relativeDensity = bulkDensity/TheoDensity;

        std::cout << "t=" << std::setprecision(3) << std::left<< getTime()
                  << " Temp= " << std::setw(3) << getTemperature()
                  << " loading stiffness= " << std::setw(3) << particleSpecies->getLoadingStiffness()
                  << " pR= " << std::setw(3) << particleHandler.getMeanRadius()
                  << " MeanOverlap= "<< std::setw(3) << sqrt(meanOverlap/meanRadius)
                  << " MAxPosi= "<< std::setw(3) << getSurfaceHeight()
                  << " volumeFractionSys= "<< std::setw(3) << volTotalParticles/volSystem
                  << " meanCoordinationN.= "<< std::setw(3) <<meanCoordinationNumber
                  << " Bulk Density= "<< std::setw(3) << bulkDensity
                  << " relativeDensity= "<< std::setw(3) << relativeDensity

                  << std::endl;
    }
};

// Main function:
int main(int argc UNUSED, char *argv[] UNUSED)
{
    Mdouble deltaR = 1.0e-4; //radius expansion

    Mdouble startingTemperature = 165.0; //Initial temperature
    Mdouble gradientTemp = 440.0;
    Mdouble maxTemp = 181.0; //max temperature
    Mdouble meltingTemperature = 180.0;

    Mdouble setDeltaC = 9.55e-07 ;
    Mdouble setC1 = 0.5;

    S3_Sintering oTest(deltaR,startingTemperature,maxTemp,gradientTemp,meltingTemperature,setDeltaC,setC1);

    oTest.setTimeMax(0.5);
    oTest.removeOldFiles();

//    oTest.setXBallsAdditionalArguments("-solidf -v0 -cmode 8 -cmaxset 100 ");
    oTest.solve();

    //--------------------------------------------------
    //This is for Coarse-Graining live.
    //Live CG to get results over time. For instance, plot stress vs time.
    //    //define coarse-graining resolved in z
    //    CG<CGCoordinates::Z> cgZ; //declare a cg object
    //    cgZ.setN(20);  //set number of mesh points in each spatial direction
    //    cgZ.setWidth(0.5); //set cg width
    //    s.cgHandler.copyAndAddObject(cgZ); // add the CG object to the cgHandler

    oTest.solve();

    //Coarse-Graining:
    //--------------------------------------------------
    // It creates the coarse-graining output file at the last iteraction.
    logger(INFO,"Execute 'source S3_Sintering.sh' to get coarse-grained statistics at specific time step");
    helpers::writeToFile("S3_Sintering.sh","../../../../../MercuryCG/fstatistics S3_Sintering -stattype XZ -w 1.0e-5 -h 0.1e-5 -tmin 1.0 -tmax 1.1 -o S3_SinteringScaledMass.XZ.stat");

    //--------------------------------------------------
    // It creates the matlab visualization.
    logger(INFO,"Run 'S3_Sintering.m' in MATLAB/octave to visualise the statistical output");
    helpers::writeToFile("S3_Sintering.m","clc;clear all;close all\n"
                                          "addpath('../../../../../MercuryCG/')\n"
                                          "data = loadStatistics('S3_Sintering.XZ.stat');\n"
                                          "colormap(1-gray)\n"
                                          "contourf(data.x,data.z,data.Density,20,'EdgeColor','none')\n"
                                          "c = colorbar\n"
                                          "c.Label.String = '\\rho';\n"
                                          "title('Density')\n"
                                          "xlabel('x')\n"
                                          "ylabel('z');\n"
                                          "axis equal\n"
                                          "%%\n"
                                          "addpath('/home/juan/Softwares/MercuryDPM_Branch/Trunk/Matlab');\n"
                                          "particles=read_data('S3_Sintering.data');\n"
                                          "Cell = particles{637}(1,1); %Specific particle position at 1.119, which is in the cell 24\n"
                                          "NumPart= Cell.N;\n"
                                          "Pradius = Cell.Radius;\n"
                                          "Position = Cell.Position;\n"
                                          "a=linspace(0,2*pi,40);\n"
                                          "xCircle = sin(a);\n"
                                          "zCircle = cos(a);\n"
                                          "hold on;\n"
                                          "for i=1:length(Pradius)\n"
                                          "  plot(Position(i,1) + Pradius(i)*xCircle,Position(i,3)+Pradius(i)*zCircle,'Color',.8*[1 1 1])\n"
                                          "end\n"
                                          "hold off");
    return 0;

    //--------------------------------------------------
    //An example of how to plot the results using gnuplot
    //Gnuplot:
    //set format xy "%.1f"
    //plot 'DensificationRateS2.fstat' using 1:2 title "Heating profile",
    //set ylabel "Temperature"
    //set xlabel "t [s]"
    //set ylabel "{/Symbol r} _{relative}"

    //Shrinkage
//    plot "S3_Sintering_250L_test2.fstat" u ($1):((0.000288-$9)/0.000288)
//    replot "S3_Sintering_250L_test2.fstat" u ($1):(0.041*$1)/(4*3405.0*33.0e-6)

    //Neck-Growth
//    replot "S3_Sintering_250L_test2.fstat" u ($1):(sqrt(0.041*$1/(3405*33.0e-6)))
//    plot "S3_Sintering_250L_test2.fstat" u ($1):($7)
}

//-----
//-----
////Copyright (c) 2013-2018, The MercuryDPM Developers Team. All rights reserved.
////For the list of developers, see <http://www.MercuryDPM.org/Team>.
////
////Redistribution and use in source and binary forms, with or without
////modification, are permitted provided that the following conditions are met:
////  * Redistributions of source code must retain the above copyright
////    notice, this list of conditions and the following disclaimer.
////  * Redistributions in binary form must reproduce the above copyright
////    notice, this list of conditions and the following disclaimer in the
////    documentation and/or other materials provided with the distribution.
////  * Neither the name MercuryDPM nor the
////    names of its contributors may be used to endorse or promote products
////    derived from this software without specific prior written permission.
////
////THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
////ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
////WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
////DISCLAIMED. IN NO EVENT SHALL THE MERCURYDPM DEVELOPERS TEAM BE LIABLE FOR ANY
////DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
////(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
////LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
////ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
////(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
////SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//#include "Mercury3D.h"
//#include "Species/ThermalSinterLinFrictionReversibleAdhesiveSpecies.h"
//#include "Walls/InfiniteWall.h"
////#include "CG/CG.h"
//
///* This code reads the information generated by S2_Compression file.
// * The temperature increases and heats up all particles. Thus, the Sintering process
// * occurs.
//*/
//// Main class:
//class S3_Sintering : public Mercury3D{
//
//private:
//    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpecies;
//    ThermalSinterLinFrictionReversibleAdhesiveSpecies* particleSpeciesAtMeltingPoint;
//    ThermalSinterLinFrictionReversibleAdhesiveSpecies* wallSpecies;
//
//    Mdouble deltaR = 1.0e-4; //[check] Thermal expansion coefficient
//
//    Mdouble meanCoordinationNumber = 0.0;
//    Mdouble newHeight = 0.0;
//
//    Mdouble gradientTemp = 250.0; //[C/s]
//    Mdouble timeCooling = 0.18; //[s]
//
//    const Mdouble startingTemp = 65.0; //[C]
//    const Mdouble meltTemp = 72.0; //[C]
//    const Mdouble maxTemp = 73.0;
//
//public:
////
//    //Constructor
//    S3_Sintering(Mdouble setTConductivity, Mdouble setHCapacity)
//    {
//        setName("HT_S1_Insertion_400L_Cylinder");
//        readRestartFile();
//        setRestarted(false);
//        setName("HT_S3_Sintering_400L_Cylinder");
//
////        wallHandler.removeLastObject();
////        wallHandler.getLastObject()->setVelocity(Vec3D(0.0,0.0,0.0));
////        wallHandler.getLastObject()->setPosition(Vec3D(0.0,0.0,getZMax()));
//
//        setParticlesWriteVTK(true);
//        setWallsWriteVTK(FileType::MULTIPLE_FILES);
//
//        particleSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(0));
//        wallSpecies = dynamic_cast<ThermalSinterLinFrictionReversibleAdhesiveSpecies*>(speciesHandler.getObject(1));
//
//        const Mdouble YoungM = 1.65e9; //[Pa] Young's Modulus for polyamide12
//
//        Mdouble K1 =  particleSpecies->getLoadingStiffness();
//
//        //Thermal parameters:
//        particleSpecies->setThermalConductivity(setTConductivity);
//        particleSpecies->setHeatCapacity(setHCapacity);
//
//        particleSpecies->setSinterType(SINTER_APPROACH::VISCOELASTIC_CONTACT);  //FRENKEL OR VISCOELASTIC_CONTACT
//
////        particleSpecies->setCohesionStiffness(K1);
//        particleSpecies->setPenetrationDepthMax(1.0);
//        particleSpecies->setComplianceZero(1.0/(2.0*YoungM)); //Book: Adhesive Particles
//        particleSpecies->setSurfTension(0.03); //
//
//        //To control:
//        particleSpecies->setSinterAdhesion(1.0e-8/particleHandler.getMeanRadius());
//
//        particleSpecies->setFluidity(6.0);
//        particleSpecies->setSeparationDis(1.8e-08);
//
//        particleSpeciesAtMeltingPoint = new ThermalSinterLinFrictionReversibleAdhesiveSpecies(*particleSpecies);
//    }
//    //--------------------------------------------------
//    //Destructure
//    ~S3_Sintering() override
//    {
//        delete particleSpeciesAtMeltingPoint;
//    }
//    //--------------------------------------------------
//    //Initial conditions
//    void setupInitialConditions() override
//    {
//        particleSpeciesAtMeltingPoint->setLoadingStiffness(particleSpecies->getLoadingStiffness());
////        particleSpeciesAtMeltingPoint->setCohesionStiffness(particleSpecies->getCohesionStiffness());
//
////        double N = particleHandler.getNumberOfObjects();
//        // Set uniform temperature to all particles.
//        for (BaseParticle* p : particleHandler)
//        {
//            auto* tp = dynamic_cast<ThermalParticle*>(p);
//            tp->setTemperature(startingTemp);
//            tp->setVelocity(Vec3D(0.0,0.0,0.0));
//        }
//        logger(INFO, "Set uniform temperature to all particles [C]= %", startingTemp);
////        for (int i=0; i < N; i++) {
////            particleHandler.getObject(i)->setSpecies(particleSpecies);
////
////        }
//    }
//    //--------------------------------------------------
//    Mdouble getTemperature()const
//    {
//        Mdouble heatingTemperature = startingTemp + gradientTemp*getTime();
//        Mdouble coolingTemperature = maxTemp;
//
//        if(getTime()>=timeCooling){
//            coolingTemperature = startingTemp + gradientTemp*(getTimeMax() - getTime());
//        }
//        return std::min(std::min(heatingTemperature,coolingTemperature),maxTemp);
//    }
//
//    void setTemperature(Mdouble temperature)
//    {
//        static Mdouble oldTemperature = startingTemp;
//        Mdouble deltaTemperature = temperature-oldTemperature;
//        Mdouble deltaCooling = temperature - meltTemp;
//
//        Mdouble factorRadius = 1.0 - (deltaR * deltaTemperature);
//
//        for (BaseParticle* p : particleHandler)
//        {
//            auto *tp = dynamic_cast<ThermalParticle *>(p);
//
//            if (p->getSpecies()==particleSpecies)
//            {
//                tp->setTemperature(temperature); //Change the temperature of the particle
//                p->setRadius((factorRadius * p->getRadius()));
//            }
//        }
//        //change species properties
//        Mdouble stiffnessFactor = 0.5*(1.0+tanh((meltTemp-temperature)/gradientTemp));
//        Mdouble oldLoadingStiffness = particleSpecies->getLoadingStiffness();
//        particleSpecies->setLoadingStiffness(stiffnessFactor*particleSpeciesAtMeltingPoint->getLoadingStiffness());
//
//        //for decreasing temperature, change the maxOverlap
//        if (deltaCooling<0.0)
//        {
//            for (BaseInteraction* cBase : interactionHandler)
//            {
//                auto c =  dynamic_cast<SinterLinInteraction*>(cBase);
//                Mdouble unloadingStiffness = c->getUnloadingStiffness();
//                c->setMaxOverlap(c->getMaxOverlap()
//                                 *(unloadingStiffness-oldLoadingStiffness)
//                                 /(unloadingStiffness-particleSpecies->getLoadingStiffness())
//                );
//            }
//        }
//        oldTemperature = temperature;
//    }
//    //--------------------------------------------------
//    void actionsAfterTimeStep() override
//    {
//        setTemperature(getTemperature());
//        newHeight = getSurfaceHeight();
//
//        //To measure the mean coordination number.
//        for (int i = particleHandler.getNumberOfObjects()-1; i>=0; i--)
//        {
//            meanCoordinationNumber += (particleHandler.getObject(i) -> getInteractions()).size();
//        }
//        meanCoordinationNumber /= particleHandler.getNumberOfObjects();
//    }
//    //--------------------------------------------------
//    //Prints the temperature into the data file, such that you can plot it in paraview
//    double getInfo(const BaseParticle& p) const override
//    {
//        return (dynamic_cast<const ThermalParticle &>(p).getTemperature()-startingTemp)/(maxTemp-startingTemp);
//    }
//    //--------------------------------------------------
//    Mdouble getSurfaceHeight() const
//    {
//        double height = 0;
//
//        for (const BaseParticle* p : particleHandler)
//        {
//            double newHeight = p->getPosition().Z;
//            if (height<newHeight) height = newHeight;
//        }
//
//        return height+particleHandler.getMeanRadius();
//    }
//    //--------------------------------------------------
//    //Function to override the output file with specific parameters
//    void writeFstatHeader(std::ostream &os) const override
//    {
//        Mdouble volSystem = constants::pi*(std::pow(getXMax()/2,2))*getSurfaceHeight();
//
//        Mdouble volTotalParticles = particleHandler.getVolume();
//        Mdouble meanOverlap = interactionHandler.getMeanOverlap();
//        Mdouble meanRadius = particleHandler.getMeanRadius();
//        Mdouble meanContactRadius = sqrt(meanOverlap/meanRadius)*meanRadius;
////        Mdouble volParticlesInSystem = constants::pi*(getXMax())*newHeight;
//        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));
//
//        Mdouble densityParticle = particleSpecies->getDensity();
//
//        Mdouble massParticle = densityParticle*volParticle;
//        Mdouble massTotalParticles = particleHandler.getMass();
//        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2,2.0))*getSurfaceHeight();
//        Mdouble bulkDensity = massTotalParticles/volParticlesPlusVoidInSystem;
//        Mdouble TheoDensity = 550.0;
//
//        os << getTime() //1
//           << " " << getTemperature()//2
//           << " " << particleSpecies->getDensity()//3
//           << " " << particleSpecies->getLoadingStiffness()//4
//           << " " << meanOverlap//5
//           << " " << meanContactRadius //6
//           << " " << sqrt(meanOverlap/meanRadius)//7
//           << " " << std::setw(3) << wallHandler.getLastObject()->getPosition().Z//8
//           << " " << getSurfaceHeight()//9
//           << " " << (wallHandler.getLastObject()->getPosition().Z-getSurfaceHeight())/wallHandler.getLastObject()->getPosition().Z//10
//           << " " << bulkDensity//11
//           << " " << TheoDensity//12
//           << " " << volTotalParticles/volSystem//13
//           << " " << meanCoordinationNumber//14
//           << " " << wallHandler.getObject(0)->getForce().Z//15
//           << std::endl;
//    }
//
//    void printTime() const override
//    {
//        Mdouble volSystem = constants::pi*(std::pow(getXMax()/2,2))*getSurfaceHeight();
//
//        Mdouble volTotalParticles = particleHandler.getVolume();
//        Mdouble meanOverlap = interactionHandler.getMeanOverlap();
//        Mdouble meanRadius = particleHandler.getMeanRadius();
////        Mdouble volParticlesInSystem = constants::pi*(getXMax())*newHeight;
//        Mdouble volParticle = (4.0/3.0)*constants::pi*(std::pow(particleHandler.getMeanRadius(),3.0));
//
//        Mdouble densityParticle = particleSpecies->getDensity();
//
//        Mdouble massParticle = densityParticle*volParticle;
//        Mdouble massTotalParticles = particleHandler.getMass();
//        Mdouble volParticlesPlusVoidInSystem = constants::pi*(std::pow(getXMax()/2,2.0))*getSurfaceHeight();
//        Mdouble bulkDensity = massTotalParticles/volParticlesPlusVoidInSystem;
//        Mdouble TheoDensity = 650.0;
////        Mdouble RealDensity = massTotalParticles/volTotalParticles;
//
//        Mdouble relativeDensity = bulkDensity/TheoDensity;
//
//        std::cout << "t=" << std::setprecision(3) << std::left<< getTime()
//                  << " Temp= " << std::setw(3) << dynamic_cast<const ThermalParticle*>(particleHandler.getObject(0))->getTemperature()
//                  //                  << " BaseWallForce= " << std::setw(3) << std::abs(wallHandler.getObject(0)->getForce().Z)
//                  //                  << " GetPositionIni= " << std::setw(3) << wallHandler.getLastObject()->getPosition().Z
//                  << " loading stiffness= " << std::setw(3) << particleSpecies->getLoadingStiffness()
//                  << " pR= " << std::setw(3) << particleHandler.getMeanRadius()
//                  << " MeanOverlap= "<< std::setw(3) << sqrt(meanOverlap/meanRadius)
//                  << " MAxPosi= "<< std::setw(3) << getSurfaceHeight()
//                  << " volumeFractionSys= "<< std::setw(3) << volTotalParticles/volSystem
//                  << " meanCoordinationN.= "<< std::setw(3) <<meanCoordinationNumber
//                  << " Bulk Density= "<< std::setw(3) << bulkDensity
//                  << " relativeDensity= "<< std::setw(3) << relativeDensity
//
//                  << std::endl;
//
////        static unsigned int counter = 0;
////        if(++counter>100 && volTotalParticles/volSystem>=1.0){
////            exit(-1);
////        }
//    }
//};
//
//// Main function:
//int main(int argc UNUSED, char *argv[] UNUSED)
//{
//    Mdouble setTConductivity = 0.167; //[W/(mK)]
//    Mdouble setHCapacity = 1320.0; //[J/(kgK)]
//
//    S3_Sintering s(setTConductivity,setHCapacity);
////    s.setTimeStep(1.0e-7);
////    s.setTimeStep(0.00002);
//
//    s.setTimeMax(0.8);
//    s.removeOldFiles();
//
//    //--------------------------------------------------
//    //This is for Coarse-Graining live.
//    //Live CG to get results over time. For instance, plot stress vs time.
//    //    //define coarse-graining resolved in z
//    //    CG<CGCoordinates::Z> cgZ; //declare a cg object
//    //    cgZ.setN(20);  //set number of mesh points in each spatial direction
//    //    cgZ.setWidth(0.5); //set cg width
//    //    s.cgHandler.copyAndAddObject(cgZ); // add the CG object to the cgHandler
//
//    s.setXBallsAdditionalArguments("-solidf -v0 -cmode 8 -cmaxset 100 ");
//
//    s.solve();
//
//    //Coarse-Graining:
//    //--------------------------------------------------
//    // It creates the coarse-graining output file at the last iteraction.
//    logger(INFO,"Execute 'source HT_S3_Sintering.sh' to get coarse-grained statistics at specific time step");
//    helpers::writeToFile("HT_S3_Sintering.sh","../../../../../MercuryCG/fstatistics HT_S3_Sintering -stattype XZ -w 1.0e-5 -h 0.1e-5 -tmin 1.0 -tmax 1.1 -o S3_SinteringScaledMass.XZ.stat");
//
//    //--------------------------------------------------
//    // It creates the matlab visualization.
//    logger(INFO,"Run 'S3_Sintering.m' in MATLAB/octave to visualise the statistical output");
//    helpers::writeToFile("HT_S3_Sintering.m","clc;clear all;close all\n"
//                                             "addpath('../../../../../MercuryCG/')\n"
//                                             "data = loadStatistics('HT_S3_Sintering.XZ.stat');\n"
//                                             "colormap(1-gray)\n"
//                                             "contourf(data.x,data.z,data.Density,20,'EdgeColor','none')\n"
//                                             "c = colorbar\n"
//                                             "c.Label.String = '\\rho';\n"
//                                             "title('Density')\n"
//                                             "xlabel('x')\n"
//                                             "ylabel('z');\n"
//                                             "axis equal\n"
//                                             "%%\n"
//                                             "addpath('/home/juan/Softwares/MercuryDPM_Branch/Trunk/Matlab');\n"
//                                             "particles=read_data('HT_S3_Sintering.data');\n"
//                                             "Cell = particles{637}(1,1); %Specific particle position at 1.119, which is in the cell 24\n"
//                                             "NumPart= Cell.N;\n"
//                                             "Pradius = Cell.Radius;\n"
//                                             "Position = Cell.Position;\n"
//                                             "a=linspace(0,2*pi,40);\n"
//                                             "xCircle = sin(a);\n"
//                                             "zCircle = cos(a);\n"
//                                             "hold on;\n"
//                                             "for i=1:length(Pradius)\n"
//                                             "  plot(Position(i,1) + Pradius(i)*xCircle,Position(i,3)+Pradius(i)*zCircle,'Color',.8*[1 1 1])\n"
//                                             "end\n"
//                                             "hold off");
//    return 0;
//
//    //--------------------------------------------------
//    //An example of how to plot the results using gnuplot
//    //Gnuplot:
//    //set format xy "%.1f"
//    //plot 'DensificationRateS2.fstat' using 1:2 title "Heating profile",
//    //set ylabel "Temperature"
//    //set xlabel "t [s]"
//    //set ylabel "{/Symbol r} _{relative}"
//
//    //Shrinkage
////    plot "S3_Sintering_250L_test2.fstat" u ($1):((0.000288-$9)/0.000288)
////    replot "S3_Sintering_250L_test2.fstat" u ($1):(0.041*$1)/(4*3405.0*33.0e-6)
//
//    //Neck-Growth
////    replot "S3_Sintering_250L_test2.fstat" u ($1):(sqrt(0.041*$1/(3405*33.0e-6)))
////    plot "S3_Sintering_250L_test2.fstat" u ($1):($7)
//}